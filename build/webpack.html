<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>打包工具和脚手架相关 | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="我的个人网站">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8f3dca9f.css" as="style"><link rel="preload" href="/assets/js/app.e6d790d2.js" as="script"><link rel="preload" href="/assets/js/2.670a8c78.js" as="script"><link rel="preload" href="/assets/js/1.71926bfe.js" as="script"><link rel="preload" href="/assets/js/50.f9fa87b4.js" as="script"><link rel="prefetch" href="/assets/js/10.66b9053d.js"><link rel="prefetch" href="/assets/js/11.04545941.js"><link rel="prefetch" href="/assets/js/12.1bdea263.js"><link rel="prefetch" href="/assets/js/13.9426da25.js"><link rel="prefetch" href="/assets/js/14.856c1518.js"><link rel="prefetch" href="/assets/js/15.b360c35b.js"><link rel="prefetch" href="/assets/js/16.e925b239.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/20.e4646aa0.js"><link rel="prefetch" href="/assets/js/21.a45f0526.js"><link rel="prefetch" href="/assets/js/22.49faaeca.js"><link rel="prefetch" href="/assets/js/23.c2b62dee.js"><link rel="prefetch" href="/assets/js/24.637d604b.js"><link rel="prefetch" href="/assets/js/25.1370aa75.js"><link rel="prefetch" href="/assets/js/26.254ee0fc.js"><link rel="prefetch" href="/assets/js/27.09790146.js"><link rel="prefetch" href="/assets/js/28.7e5b1948.js"><link rel="prefetch" href="/assets/js/29.fce874c1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/30.a2fe8eb2.js"><link rel="prefetch" href="/assets/js/31.162506d4.js"><link rel="prefetch" href="/assets/js/32.3cde0674.js"><link rel="prefetch" href="/assets/js/33.d7d3d255.js"><link rel="prefetch" href="/assets/js/34.70bab86a.js"><link rel="prefetch" href="/assets/js/35.e25e2604.js"><link rel="prefetch" href="/assets/js/36.b5fada05.js"><link rel="prefetch" href="/assets/js/37.e2f9bc23.js"><link rel="prefetch" href="/assets/js/38.24d3a67d.js"><link rel="prefetch" href="/assets/js/39.2b6a21e0.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.d406595a.js"><link rel="prefetch" href="/assets/js/41.917cf6ec.js"><link rel="prefetch" href="/assets/js/42.2a915dbf.js"><link rel="prefetch" href="/assets/js/43.06d233c4.js"><link rel="prefetch" href="/assets/js/44.f41cf9e5.js"><link rel="prefetch" href="/assets/js/45.2f577289.js"><link rel="prefetch" href="/assets/js/46.69e142ff.js"><link rel="prefetch" href="/assets/js/47.6967f1f2.js"><link rel="prefetch" href="/assets/js/48.c42a0925.js"><link rel="prefetch" href="/assets/js/49.396ed3db.js"><link rel="prefetch" href="/assets/js/5.b31b942f.js"><link rel="prefetch" href="/assets/js/51.f5150e72.js"><link rel="prefetch" href="/assets/js/52.5b2e9eb6.js"><link rel="prefetch" href="/assets/js/53.775f3eb1.js"><link rel="prefetch" href="/assets/js/54.af0c3dd1.js"><link rel="prefetch" href="/assets/js/55.062c9831.js"><link rel="prefetch" href="/assets/js/56.3228b669.js"><link rel="prefetch" href="/assets/js/57.3e194052.js"><link rel="prefetch" href="/assets/js/58.0fac8851.js"><link rel="prefetch" href="/assets/js/59.4a2921bc.js"><link rel="prefetch" href="/assets/js/6.4910e764.js"><link rel="prefetch" href="/assets/js/60.aaff0e8d.js"><link rel="prefetch" href="/assets/js/61.4094ca3e.js"><link rel="prefetch" href="/assets/js/62.a4d3e4b0.js"><link rel="prefetch" href="/assets/js/63.90c7781d.js"><link rel="prefetch" href="/assets/js/64.9f28672a.js"><link rel="prefetch" href="/assets/js/65.82d99a34.js"><link rel="prefetch" href="/assets/js/66.4b1a7c79.js"><link rel="prefetch" href="/assets/js/67.cde2a4b8.js"><link rel="prefetch" href="/assets/js/68.7b2ca4b4.js"><link rel="prefetch" href="/assets/js/69.3f6a7106.js"><link rel="prefetch" href="/assets/js/7.c5640ac7.js"><link rel="prefetch" href="/assets/js/70.97a2a772.js"><link rel="prefetch" href="/assets/js/71.35881c3b.js"><link rel="prefetch" href="/assets/js/72.25b350dc.js"><link rel="prefetch" href="/assets/js/73.11c7d3f8.js"><link rel="prefetch" href="/assets/js/74.920a6416.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3dca9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="打包工具和脚手架相关"><a href="#打包工具和脚手架相关" class="header-anchor">#</a> 打包工具和脚手架相关</h1> <h1 id="打包工具"><a href="#打包工具" class="header-anchor">#</a> 打包工具</h1> <h3 id="npm安装的背后思想"><a href="#npm安装的背后思想" class="header-anchor">#</a> npm安装的背后思想</h3> <ul><li>执行npm install命令后，会先检查并获取npm配置，这里的优先级为，</li></ul> <blockquote><p>项目的.npmrc文件&gt;用户的.npmrc文件&gt;全局的.cnpmrc文件&gt;npm内置的.npmrc文件</p></blockquote> <ul><li>然后检查项目中是否有package-lock.json文件
<ul><li>如果有，检查package-lock.json和package.json中声明的依赖是否一致，不一致，按照package.json安装，并更新package-lock.json</li> <li>如果没有就根据package.json递归构建依赖树，然后按照构建好的依赖树下载完整的依赖资源，在下载时会检查是否存在相关资源缓存
<ul><li>存在就将缓存内容解压到node_modules中，</li> <li>否则就先从npm远程仓库下载包，校验包的完整性，并添加到缓存，同时解压node——modules，最后生成package-lock.json</li></ul></li></ul></li></ul> <h3 id="npx的作用"><a href="#npx的作用" class="header-anchor">#</a> npx的作用</h3> <blockquote><p>解决痛点是，npm的一些快速开发，调试，以及项目内使用全局模块的痛点</p></blockquote> <ul><li>实现的原理是，它可以直接执行node_modules/.bin文件夹下的文件，在运行命令时，npx可自动去node_modules/.bin路径和环境变量 $PATH 里检查命令是否存在，而不需去package.json中定义相关script</li> <li>还有一个更实用的好处是，npx执行模块时会优先安装依赖，但是安装执行后便删除依赖，这就避免全局安装模块带来的问题。
比如运行如下命令，npx会将 create-react-app 下载到一个临时目录，使用以后再删除</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>npx create<span class="token operator">-</span>react<span class="token operator">-</span>app cra<span class="token operator">-</span>project
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="yarn解决的问题"><a href="#yarn解决的问题" class="header-anchor">#</a> yarn解决的问题</h3> <ul><li>通过yarn.lock等机制，保证了确定性，相同的依赖环境在任何机器和容器下都可以以相同的方式被安装</li> <li>采用模块扁平安装模式，将依赖包的不同版本，按照一定策略归结为单个版本，已避免创建多个副本造成冗余</li> <li>网络性能更好，yarn采用请求排队理念，类似并发连接池，能更好的利用网络资源，同时引入更好的安装失败时的重试机制</li> <li>采用缓存机制，实现了离线模式</li></ul> <p>安装机制：</p> <blockquote><p>检测包 =》 解析包 =》 获取包 =》链接包 =》 构建包
主要流程是检测项目中是否存在一些npm相关we年，再获取package.json定义的依赖，采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个Set数据解决来存储。</p></blockquote> <h2 id="ci环境的npm优化及更多工程问题解析"><a href="#ci环境的npm优化及更多工程问题解析" class="header-anchor">#</a> ci环境的npm优化及更多工程问题解析</h2> <p>上传package-lock.json到仓库中，以保证依赖安装的一致性，项目中使用package-loack.json还可以显著加速依赖安装时间，这是应为package-lock.json中缓存了每个包的具体版本和下载链接，不需要再去远程仓库查询。</p> <ul><li>使用npm的建议
<ul><li>使用高版本的npm，保证npm的最基本的先进和稳定性</li> <li>可以修改package.json中版本号，并执行npm install来升级版本</li> <li>删除某些依赖，执行npm uninstall命令验证没问题后，提交新的package.json、package-lock.json文件。</li></ul></li></ul> <h2 id="一个现代化构建工具-需要重点考量-实现哪些环节"><a href="#一个现代化构建工具-需要重点考量-实现哪些环节" class="header-anchor">#</a> 一个现代化构建工具，需要重点考量/实现哪些环节</h2> <ol><li>code splitting</li></ol> <ul><li>代码分割，在构建打包时，能导出公共模块、避免重复打包、以及页面加载运行时，实现最合理的按需加载策略。</li></ul> <ol start="2"><li>hashing</li></ol> <ul><li>最大化的利用缓存机制，构建工具进行打包的前提是对各个模块依赖关系进行分析，并根据依赖关系，支持开发者自行定义hash策略</li> <li>就出现了chunkhash和contenthash
<ul><li>chunkhash会根据入口文件进行依赖解析，如果改动了业务项目入口文件，就不会引起公共库的hash值变化</li> <li>contenthash会根据文件具体内容生成hash值，</li></ul></li></ul> <ol start="3"><li>Importing Modules，即依赖机制
兼容不能履行的modulkes importing方案</li> <li>对解析和导入非js资源的支持能力，比如图片，css，html等资源文件</li> <li>支持配置多种打包模式的输出</li> <li>Transformations： 支持对代码压缩，无用代码删除。</li></ol> <h1 id="babel"><a href="#babel" class="header-anchor">#</a> Babel</h1> <ul><li>babel-polyfill，提供代码补丁，可以在不兼容某些新特性上，实现该新特性，但是如果粗暴一次性导入，会在成项目size过大，且污染全局变量的问题</li> <li>babel-polyfill结合@babel/preset-env + useBuiltins（usage） + preset-env targets 的方案是更流程的，可根据环境自动按需加载polyfills</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string-property property">'presets'</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token string">'@babel/env'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">useBuiltIns</span><span class="token operator">:</span> <span class="token string">'usage'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">targets</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">chrome</span><span class="token operator">:</span> <span class="token number">44</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里的useBuiltins配置为usage，他可以真正根据代码情况，分析AST进行更细颗粒度的按需引用，但是这种基于静态编译的按需加载补丁也是相对的，应为javascript是一种弱规则动态语音，比如代码foo.includes(() =&gt; {}),无法判断这里是includes是数组原型还是字符串原型。，一版做法就是将两种同时打包</p> <ul><li>从工程化的角度来看，一个趋于完美的polyfill设计应该满足的核心原则是按需加载补丁，主要包括按照用户终端环境和按照业务代码使用情况。</li></ul> <h2 id="babel是什么"><a href="#babel是什么" class="header-anchor">#</a> Babel是什么</h2> <ul><li>@babel/core 是Babel实现转换的核心</li> <li>@babel/cli 是Babel提供的命令行，可在终端通过命令行的方式运行，编译文件或目录</li> <li>@babel/standalone 可在非node.js环境下，自动编译含text/babel或text/jsx的type值得script标签，可在浏览器直接执行。</li> <li>@babel/parser Babel用来对js语言解析的解析器，返回一个针对源码编译得到的AST</li> <li>@babel/traverse 对AST遍历的能力</li> <li>@babel/types 提供对具体AST节点修改的能力</li> <li>@babel/generator 对新的AST进行聚合生成js代码</li> <li>@babel/preset-env  直接暴露给开发者在业务中运行包的能力</li> <li>@babel/runtime 含有Babel编译时所需的一些运行的helpers，供业务代码引入模块化的Babel helpers函数，对generator和async函数进行降级。</li> <li>@babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用；@babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的；@babel/runtime 用于运行时，作为 dependencies 使用</li> <li>@babel/plugin-syntax-* 是 Babel 的语法插件，作用是扩展@babel、parser的一些能力，提供给工程使用。</li> <li>@babel/plugin-proposal-* 用于编译转换在提议阶段的语言特性</li> <li>@babel/plugin-transform-* 是 Babel 的转换插件， 比如简单的 @babel/plugin-transform-react-display-name 插件，可以自动适配 React 组件 DisplayName</li></ul> <h2 id="指定一个企业级公共库的设计原则"><a href="#指定一个企业级公共库的设计原则" class="header-anchor">#</a> 指定一个企业级公共库的设计原则</h2> <ul><li>对于开发者共创的公共库，最大化确保开发体验，最快的搭建调试和开发环境，安全的发版维护</li> <li>公共库文档建设完善，公共库指质量保障，接入和使用负担最小</li></ul> <h3 id="实战打造一个公共库"><a href="#实战打造一个公共库" class="header-anchor">#</a> 实战打造一个公共库</h3> <ol><li>支持script标签引入，可以将公共库脚本编译为 UMD 方式，浏览器可直接引入打包后dist目录中的编译后资源，如果需要支持全局命名空间，需配置插件</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">&quot;@babel/plugin-transform-modules-umd&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">exactGlobals</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">globals</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">index</span><span class="token operator">:</span> <span class="token string">'AnimalApi'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>还可在webpack.config.js中的output配置library将xxx作为公共库对外暴露的命名空间，libraryTarget： var。</p> <h2 id="代码拆分和按需加载-缩减-bundle-size-性能做到极致"><a href="#代码拆分和按需加载-缩减-bundle-size-性能做到极致" class="header-anchor">#</a> 代码拆分和按需加载：缩减 bundle size，性能做到极致</h2> <ul><li>按需加载表示代码模块在交互需要时，动态引入，按需打包针对第三方依赖库，以及业务模块，只打包真正运行时可能会需要的代码。</li> <li>目前按需打包通过两种方式进行
<ul><li>使用ES Module支持的Tree Shaking方案，在使用构建工具时，完成按需打包</li> <li>使用babel-plugin-import为主的Babel插件，实现自动按需打包。</li></ul></li></ul> <h3 id="babel-plugin-import原理"><a href="#babel-plugin-import原理" class="header-anchor">#</a> babel-plugin-import原理</h3> <ul><li>babel插件核心依赖于对AST的解析和操作，通过对AST语法树进行转换的过程中介入，通过相应的操作，最终让生成的结果发生改变。</li></ul> <h3 id="动态导入以及按需加载"><a href="#动态导入以及按需加载" class="header-anchor">#</a> 动态导入以及按需加载</h3> <ul><li>早起import是完全静态化，现在dynamic import可以进行动态导入</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 实现一个dynamicImport</span>
<span class="token keyword">const</span> <span class="token function-variable function">importModule</span> <span class="token operator">=</span> <span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> tempGlobal <span class="token operator">=</span> <span class="token string">&quot;__tempModuleLoadingVariable&quot;</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'module'</span>
    script<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">import * as m from &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;; window.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tempGlobal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> = m;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token comment">// load回调</span>
    script<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span>tempGlobal<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">delete</span> window<span class="token punctuation">[</span>tempGlobal<span class="token punctuation">]</span>
      script<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// error回调</span>
    script<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to load module script with URL &quot;</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">delete</span> window<span class="token punctuation">[</span>tempGlobal<span class="token punctuation">]</span>
      script<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="webpack-赋能代码拆分和按需加载"><a href="#webpack-赋能代码拆分和按需加载" class="header-anchor">#</a> Webpack 赋能代码拆分和按需加载</h3> <ul><li>通过入口配置手动分割代码</li> <li>动态导入支持： require.evsure(), 能将其参数对应的文件拆分到一个单独的bundle中，次bundle会被异步加载，目前已被dynamic import取代。调用import(), 被请求的模块和它引用的所有子模块，会分离到一个单独的chunk中。</li> <li>通过splitChunk插件提取公共代码（公共代码分割）</li></ul> <h4 id="webpack在编译构建时-是怎么处理代码中的dynamic-import的呢。"><a href="#webpack在编译构建时-是怎么处理代码中的dynamic-import的呢。" class="header-anchor">#</a> webpack在编译构建时，是怎么处理代码中的dynamic import的呢。</h4> <p>在webpack构建时，可以读取到import参数，即便是参数内的注释部分，webpack也可以获取并理解，<code>webpackChunkName: &quot;chunk-name&quot;, webpackMode: &quot;lazy&quot;</code>,</p> <p>具体流程</p> <ol><li>开始加载异步脚本</li> <li>存储异步脚本的promise回调</li> <li>发起jsonp请求，异步加载脚本，并定义成功、失败回调</li> <li>异步脚本执行</li> <li>异步脚本执行完毕后，执行全局被重写的push方法</li> <li>在被重写的push方法中，执行异步脚本promise回调</li> <li>执行加载成功的回调</li></ol> <h4 id="webpack-中-splitchunk-插件和代码分割"><a href="#webpack-中-splitchunk-插件和代码分割" class="header-anchor">#</a> Webpack 中 splitChunk 插件和代码分割</h4> <blockquote><p>代码分割的核心意义在于避免重复打包以及提升缓存利用率，进而提升访问速度，我们将不常变化的第三方依赖库进行代码拆分，方便对第三方依赖库缓存，同时抽离公共逻辑，减少单个文件的size大小</p></blockquote> <ul><li>可被共享（即被重复引用的）模块或者node_modules中的模块</li> <li>在压缩前体积大于30kb的模块</li> <li>在按需加载模块时，并行加载的模块不得超过5个</li> <li>在页面初始化加载时，并行加载的模块不得超过3个。</li></ul> <h2 id="tree-shaking-移除javascript上下文中未引用的代码"><a href="#tree-shaking-移除javascript上下文中未引用的代码" class="header-anchor">#</a> tree shaking： 移除javascript上下文中未引用的代码</h2> <blockquote><p>tree shaking是在编译时进行无用代码消除，因此需在编译时确定依赖关系，进而确定哪些代码可被摇掉。</p></blockquote> <ul><li>import模块名只能是字符串常量</li> <li>import一般只能在模块的最顶层出现</li> <li>import binding是immutable的</li></ul> <ol><li>这些特点使得ESM具有静态分析的能力，而CommonJS定义的模块化规范，只有在执行代码后，才能动态确定依赖模块，因此不具备Tree Shaking的先天条件</li> <li>副作用模块</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> memoizedAdd <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">memoize</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>创建一个纯函数add，如果没有其他模块引用add函数，那么add函数可以被Tree Shaking掉，接着调用window.memoize方法，并传入add函数作为其参数。</li> <li>工程化工具比如webpack并不知道window.memoize方法会做什么事情，会触发某些副作用</li> <li>打包工具为了安全起见，几遍没有其他模块依赖的add函数，那么也要将add函数打包到最后的bundle中</li> <li>为了解决副作用模块，webpack给出了自己的方案，可利用package.json的sideEffects属性告诉工程化哪些模块具有副作用。哪些剩余模块没有副作用可以被Tree Shaking优化</li> <li>设置最小化副作用范围，以及原子化和颗粒化的导出。</li></ul> <h3 id="webpack-和-tree-shaking"><a href="#webpack-和-tree-shaking" class="header-anchor">#</a> Webpack 和 Tree Shaking</h3> <p>在webpack4.0会自动开启Tree Shakink能力，<code>usedExports</code>对模块进行分析和标记，而这些压缩插件负责根据标记结果进行代码删除。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">optimization</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">usedExports</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 收集的信息会被其他优化手段或者代码生成使用，比如未使用的导出内容不会被生成，导出内容会被处理成单个标记字符，压缩工具中的无用代码清除会受益于改选项</span>
    <span class="token literal-property property">minimizer</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token keyword">new</span> <span class="token class-name">TreserPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 支持删除死代码的压缩器</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="vue-和-tree-shaking"><a href="#vue-和-tree-shaking" class="header-anchor">#</a> Vue 和 Tree shaking</h3> <p>在vue2.0中，Vue对象会存在一些全局API，比如<code>Vue.nextTick(() =&gt; {})</code>,这种api就算没有被使用也不容易tree Shaking掉，在vue3.0中进行重构，全局API需通过原生ES Module的引用方式进行具名引用。<code>import { nextTick } from 'vue'</code></p> <h3 id="如何设计一个兼顾-tree-shaking-和易用性的公共库"><a href="#如何设计一个兼顾-tree-shaking-和易用性的公共库" class="header-anchor">#</a> 如何设计一个兼顾 Tree Shaking 和易用性的公共库</h3> <blockquote><p>如果我们一ESM的方式对外暴露代码，那么就很难直接兼容CommonJS规范，也就是说在Node.js环境中，使用者直接以require方式引用的话，就会报错，如果以CommonJS规范对外暴露代码，又不利于Tree Shaking</p></blockquote> <p>package.json 语法中，只有一个入口main,main来暴露 CommonJS 规范打包的代码dist/index.cjs.js，module并非 package.json 的标准字段，而是打包工具专用的字段，用来指定符合 ESM 标准的入口文件</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Library&quot;</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;dist/index.cjs.js&quot;</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;dist/index.esm.js&quot;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当<code>require('Library')</code>时，webpack会找到<code>dist/index.cjs.js</code>,当<code>import Library from 'Library'</code>，webpack会找到<code>dist/index.esm.js</code></p> <h3 id="css-和-tree-shaking"><a href="#css-和-tree-shaking" class="header-anchor">#</a> CSS 和 Tree Shaking</h3> <blockquote><p>实现原理，css的tree shaking要在样式表中，找出没有被应用带选择器样式，进行删除，核心原理是利用PostCSS插件能力，基于AST技术，找出无用代码进行删除</p></blockquote> <ul><li>遍历所有css文件的选择器</li> <li>根据所有css文件的选择器，在js代码中完成选择器匹配</li> <li>如果没有匹配到，则删除对应选择器的样式代码</li></ul> <p>遍历css选择器是利用<code>Babel</code>依靠ASt技术，完成对js代码的遍历分析。在样式世界中，PostCss起到了Babel作用，提供一个解析器，它能将CSS解析成AST抽象语法树，达到Tree Shaking目的</p> <h3 id="如何理解-ast-实现和编译原理"><a href="#如何理解-ast-实现和编译原理" class="header-anchor">#</a> 如何理解 AST 实现和编译原理</h3> <blockquote><p>解析步骤： 源代码 =》 词法分析 =》 分词结果 =》 语法分析 =》 AST</p></blockquote> <h3 id="webpack-的初心和揭秘"><a href="#webpack-的初心和揭秘" class="header-anchor">#</a> Webpack 的初心和揭秘</h3> <blockquote><p>不是所有浏览器都直接支持javascript规范，前端需要管理依赖脚本，把控不同脚本加载的顺序，前端按需加载不同类型的静态资源， 并保证每个模块都处于一个隔离的函数作用域范围</p></blockquote> <ul><li>过程： 启动项目打包器 =》 分析入口脚本 =》 递归解析AST获取依赖 =》 以入口脚本为起点递归执行模块 =》 产出bundle</li> <li>Webpack 理念：
<ul><li>使用module map 维护项目中的依赖关系</li> <li>使用包裹函数，对每个模块进行包裹</li> <li>最终合并bundle内容</li></ul></li> <li>Rollup
<ul><li>使每个模块拍平</li> <li>不使用包裹函数，不需对每个模块进行包裹</li></ul></li></ul> <h4 id="手动实现打包器"><a href="#手动实现打包器" class="header-anchor">#</a> 手动实现打包器</h4> <ul><li>读取入口文件，基于AST分析入口文件，并产出依赖列表</li> <li>使用Babel将相关模块编译成ES5</li> <li>将每个依赖模块产出一个唯一的ID，方便后续读取模块相关内容</li> <li>将每个模块以及经过Babel编译后的内容，存储到一个对象中进行维护</li> <li>遍历上一步中的对象，构建出一个依赖图，将模块内容产出</li></ul> <h2 id="从编译到运行-跨端解析小程序多端方案"><a href="#从编译到运行-跨端解析小程序多端方案" class="header-anchor">#</a> 从编译到运行，跨端解析小程序多端方案</h2> <p>单纯的编译时方案或运行时方案都不能完全满足跨端需求，因此两者结合而成的第三种，编译时和运行时的结合方案，是目前的主流技术</p> <h3 id="小程序多端-编译时方案"><a href="#小程序多端-编译时方案" class="header-anchor">#</a> 小程序多端——编译时方案</h3> <blockquote><p>主要工作量是集中在编译转化环节上，这类多段框架基于AST技术进行各平台小程序适配，主要流程如下
开发者代码 类vue/react =》 AST解析成AST树 =》 经过修改优化生成新AST树 =》 生成小程序代码</p></blockquote> <ul><li>已类vue实现的mpvue为例
<ul><li>内置Vue runtime能力，同时添加小程序平台支持，实例化一个vue实例，运行时将vue实例和小程序实例进行关联，做到数据变动时，小程序调用setData() 渲染层更新，也生成一份虚拟节点VNode，diff新旧两份虚拟节点patch。</li> <li>这样就做到了数据部分让vue运行版接手，渲染部分让小程序架构接手。</li></ul></li> <li>类 React 风格的编译时和运行时结合方案（tora）
<ul><li>强行静态编译</li> <li>运行时处理型</li></ul></li> <li>在VNodeData数据中包含了节点信息，比如type通过递归VNodeData这个数据结构，根据不同的type渲染出不同的小程序模板，比如 <code>type=&quot;view&quot;</code></li> <li>在初始化阶段第一次mount，通过<code>setData()</code>初始化小程序，具体通过递归数据结构，渲染小程序页面，在数据计算阶段，通过react计算信息，更新数据，通过setData方法触发小程序的渲染更新。</li></ul> <h2 id="升级webpack4踩的坑"><a href="#升级webpack4踩的坑" class="header-anchor">#</a> 升级webpack4踩的坑</h2> <ul><li>原本压缩js的插件被废弃，需要安装新的插件</li> <li>提取第三方库和公共模块的CommonChunkPlugin被废弃，使用optimization.splitChunks，对模块进行拆包，css提取也变了mini-css-extract-plugin</li> <li>更新vue-loader以及在配置的plugin中new该插件，vue和vue-loader匹配问题</li> <li>添加mode我，默认为production</li> <li>babel插件，webpack不支持import动态加载，需要使用babel-plugin-dynamic-import-webpack插件</li> <li>引入了tree shaking 不打包无用代码，通过import和export的静态结果特性</li></ul> <h2 id="组件实现按需加载"><a href="#组件实现按需加载" class="header-anchor">#</a> 组件实现按需加载</h2> <h3 id="单独打包样式和组件"><a href="#单独打包样式和组件" class="header-anchor">#</a> 单独打包样式和组件</h3> <ol><li>打包单独的css文件</li> <li>打包单独的组件内容
通过<code>babel-plugin-import</code>来实现按需加载</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span>
      <span class="token string">&quot;import&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token string-property property">&quot;libraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react-ui-components-library&quot;</span><span class="token punctuation">,</span>
        <span class="token string-property property">&quot;libraryDirectory&quot;</span><span class="token operator">:</span> <span class="token string">&quot;lib/components&quot;</span><span class="token punctuation">,</span>
        <span class="token string-property property">&quot;camel2DashComponentName&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>分析模块依赖关系，impoer的包是不是antd，也就是libraryName，是的话就收集起来，在判断这些是否，得到这些依赖关系之后，在生成引入代码。</p> <h2 id="webpack优化"><a href="#webpack优化" class="header-anchor">#</a> webpack优化</h2> <h3 id="production模块打包自带优化"><a href="#production模块打包自带优化" class="header-anchor">#</a> production模块打包自带优化</h3> <ul><li><p>tree-shaking</p></li> <li><p>打包时移除js中未使用的代码，它依赖于ES6模块的import和export的静态结构特性，开发时引入一个模块，如果只引用了其中一个功能，上线打包时只会把用到的功能打包进bundle中，其他没用到的不会打包进来。实现一个最简单的优化</p></li> <li><p>es6是采用静态模块，在编译时就能确定模块之间的依赖关系，每个模块的输入输出都是确定的，es6import进去是值得引用，内部改变了值会影响到值得输出，但是可以通过静态文件分析，在编译时候确定模块之间的依赖关系，通过tree-shrking的方式删除无用代码，减少文件体积，从而提高运行性能。</p></li> <li><p>scope hoisting
分析模块之间的依赖关系，尽可能的将打散的模块合并到一个函数中，但是前提是不造成代码冗余，因此只有那些被引用了一次的模块可能被合并，scope hoisting必须知道模块之间的依赖关系，就必须使用es6模块语句。</p></li></ul> <h3 id="css优化"><a href="#css优化" class="header-anchor">#</a> css优化</h3> <ul><li>将css提取到独立文件中，对每个包含css的js文件都创建一个css文件，支持按需加载css和sourceMap，可用于异步加载，不重复编译，性能更好。</li> <li>使用<code>optimize-css-assets-webpack-plugin</code>插件来完成css压缩</li></ul> <h2 id="js优化"><a href="#js优化" class="header-anchor">#</a> js优化</h2> <p>code splitting，把代码分离到不同的bundle中，可以按需加载或者并行加载这些文件，代码分离用于获取更小的bundle，以及控制资源加载优先级</p> <h3 id="通过splitchunksplugin配置参数"><a href="#通过splitchunksplugin配置参数" class="header-anchor">#</a> 通过splitChunksPlugin配置参数</h3> <ul><li>公用代码或者node_modules文件组成的组件模块</li> <li>打包的代码大小超过30kb，最小化压缩之前</li> <li>按需加载代码时，同时发送请求最大数量不超过5</li> <li>页面初始化同时发送请求最大数量不超过3</li></ul> <h3 id="noparse"><a href="#noparse" class="header-anchor">#</a> noparse</h3> <p>在引用第三方模块时，比如jq、bootstrap这些，内部不会依赖其他模块，就不需要webpack再去解析他们内部依赖关系</p> <h3 id="ddlplugin"><a href="#ddlplugin" class="header-anchor">#</a> ddlplugin</h3> <p>在应用第三方模块时，例如vue、react，这些框架文件一版是不会修改，而每次打包都需要去解析他们，会影响打包速度。通过dllPlugin插件实现一个个动态链接库，只构建一次，从而节省打包时间
只要用来DllPlugin和DllReferencePlugin插件</p> <h2 id="开启多线程压缩和happpack"><a href="#开启多线程压缩和happpack" class="header-anchor">#</a> 开启多线程压缩和happPack</h2> <h2 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" class="header-anchor">#</a> ES6 模块与 CommonJS 模块的差异</h2> <ul><li>commonjs输出的是一个值得拷贝，es模块输出是值得引用
<ul><li>commonjs模块输出是值得拷贝，一旦输出这个值，模块内部的变化就影响到这个值</li> <li>js引擎对脚本静态分析时，遇到模块加载命令import，就只生成一个只读引用，等到脚本真正执行时吗，在根据这个只读引用，到被加载的模块中读取值</li></ul></li> <li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
<ul><li>运行时加载，commonks模块就是对象，输出时先加载整个模块，生成一个对象，然后再从对象上读取方法，被称为运行时加载</li> <li>编译时加载，import可以执行加载某个输出值，而不是加载整个模块</li> <li>import命令会被js引擎静态分析，在编译时就引入模块代码，而不是代码运行时加载，无法实现条件加载，而且必须运行在顶层，只能是字符串常亮。</li></ul></li></ul> <h2 id="css-modules-和-scoped"><a href="#css-modules-和-scoped" class="header-anchor">#</a> CSS Modules 和 scoped</h2> <ul><li>css Modules 通过样式名给hash字符串后缀方式，在特定作用域语境中的样式编译后样式全局唯一，直接替换了类名，只适用于某个组件，其他组件不适用</li> <li>scoped 在dom结构以及css样式上加上唯一不重复的标记，保证唯一，形成模块私有化的目的，不会被其他组件污染</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6d790d2.js" defer></script><script src="/assets/js/2.670a8c78.js" defer></script><script src="/assets/js/1.71926bfe.js" defer></script><script src="/assets/js/50.f9fa87b4.js" defer></script>
  </body>
</html>
