(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{311:function(e,t,a){"use strict";a.r(t);var v=a(14),s=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue-原理解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-原理解析"}},[e._v("#")]),e._v(" Vue 原理解析")]),e._v(" "),t("ul",[t("li",[e._v("参考")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("https://blog.csdn.net/qq_46299172/article/details/107609251\nhttps://juejin.cn/post/6844903894980509703\nhttp://caibaojian.com/vue-design/art/9vue-state-init.html\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"初始化时beforecreate之前做了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化时beforecreate之前做了什么"}},[e._v("#")]),e._v(" 初始化时beforeCreate之前做了什么")]),e._v(" "),t("p",[e._v("在执行"),t("code",[e._v("new Vue()")]),e._v("时，内部会执行一个"),t("code",[e._v("this._init()")]),e._v("，是在"),t("code",[e._v("initMixin(Vue)")]),e._v("内定义的")]),e._v(" "),t("h3",{attrs:{id:"合并options配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并options配置"}},[e._v("#")]),e._v(" 合并options配置")]),e._v(" "),t("p",[e._v("合并完options并在实例上挂载一个"),t("code",[e._v("$options")]),e._v("属性")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("初始化new Vue()\n在执行"),t("code",[e._v("new Vue")]),e._v("构造函数时，参数是一个对象，也就是用户自定义配置，会将它和"),t("code",[e._v("vue")]),e._v("之前定义的原型方法，全局"),t("code",[e._v("API")]),e._v("属性，还有全局的"),t("code",[e._v("Vue.mixin")]),e._v("内的参数进行合并,合并成一个新的"),t("code",[e._v("options")]),e._v("，最后赋值给一个新属性"),t("code",[e._v("$options")])])]),e._v(" "),t("li",[t("p",[e._v("子组件初始化\n如果是子组件初始化，除了合并以上那些外，还会将父组件的参数进行合并，比如父组件在子组件上顶一个"),t("code",[e._v("event、props")]),e._v("等")])])]),e._v(" "),t("p",[e._v("经过合并之后就可以通过"),t("code",[e._v("this.$options.data")]),e._v("访问到用户定义的data函数,"),t("code",[e._v("this.$options.name")]),e._v("访问到用户定义的组件名称")]),e._v(" "),t("p",[e._v("会按照顺序初始化方法")]),e._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[e._v("initLifecycle")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("initEvents")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("initRender")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("ul",[t("li",[t("p",[t("code",[e._v("initLifecycle(vm)")]),e._v(" 主要是确定组件的父子关系和初始化某些实例属性")]),e._v(" "),t("ul",[t("li",[e._v("判断parent结单是否存在，并且判断是否存在抽象节点，如父实例parent是抽象组件，则继续找parent上的parent，直到找到非抽象组件为止。然后将当前实例push到找到父级的"),t("code",[e._v("$children")]),e._v("实例属性内，建立父子关系")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("initEvents(vm)")]),e._v("主要作用是将父组件在使用v-on或@注册的自定义事件添加到子组件的事件中心")]),e._v(" "),t("ul",[t("li",[e._v("原生事件\n"),t("ul",[t("li",[e._v("在执行"),t("code",[e._v("initEvents")]),e._v("之前的模板编译阶段，会判断遇到的是"),t("code",[e._v("html标签")]),e._v("还是组件名，如果是"),t("code",[e._v("html标签")]),e._v("会转为"),t("code",[e._v("真实dom")]),e._v("之后使用"),t("code",[e._v("addEventListener")]),e._v("注册浏览器原生事件。绑定事件是"),t("code",[e._v("挂载dom")]),e._v("的最后阶段，这只是初始阶段")])])]),e._v(" "),t("li",[e._v("自定义事件\n"),t("ul",[t("li",[e._v("经历"),t("code",[e._v("options")]),e._v("阶段后，子组件就可从"),t("code",[e._v("vm.$options._parentListeners")]),e._v("读取到父组件的自定义事件")])])])]),e._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("  "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("child"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("components @select"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"handleSelect"')]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("传过来的时间数据格式是"),t("code",[e._v("{select: function(){}}")]),e._v("在"),t("code",[e._v("initEvents")]),e._v("方法内定义"),t("code",[e._v("vm._events")]),e._v("用来存储传过来的时间集合")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("initRender(vm)")]),e._v("主要作用是挂载可以将"),t("code",[e._v("render函数")]),e._v("转为"),t("code",[e._v("vnode方法")])]),e._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("initRender")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("vm")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_vnode "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("_c")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" d")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//转化编译器的")]),e._v("\n  vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("$createElement")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" d")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("createElement")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" d"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 转化手写的")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("`\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br")])]),t("ul",[t("li",[e._v("vm._c转换的是通过编译器将tempate转换而来的render函数")]),e._v(" "),t("li",[e._v("vm.$createElement转换的是用户自定义的render函数，将内部自定义的树形结构数据转为vnode实例")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("callHook(vm, 'beforeCreate')")])]),e._v(" "),t("ul",[t("li",[e._v("实例的第一个生命周期钩子阶段的初始化, 确认组件"),t("code",[e._v("(Vue实例)")]),e._v("父子关系，将父组件的自定义事件传递给子组件，提供将render函数转化为vnode方法，执行组件beforeCreate钩子函数")]),e._v(" "),t("li",[e._v("插件内部的"),t("code",[e._v("install")]),e._v("方法是通过"),t("code",[e._v("Vue.use")]),e._v("方法安装一般选择在"),t("code",[e._v("beforeCreated")]),e._v("，是由于这个时候可以访问到vue实例，可以进行必要的初始化")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("initInjections(vm)")]),e._v(" 主要作用是初始化inject，可以访问到对应的依赖\n"),t("code",[e._v("provide和inject")]),e._v("主要是为高阶组件/组件库提供实例")])])]),e._v(" "),t("h2",{attrs:{id:"初始化时created之前做了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化时created之前做了什么"}},[e._v("#")]),e._v(" 初始化时created之前做了什么")]),e._v(" "),t("h3",{attrs:{id:"initstate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initstate"}},[e._v("#")]),e._v(" initState")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("initProps")]),e._v(" "),t("ul",[t("li",[e._v("在定义"),t("code",[e._v("props")]),e._v("数据时，不将prop值转为响应式数据，值得注意的是，由于"),t("code",[e._v("props")]),e._v("本身通过"),t("code",[e._v("defineReactive")]),e._v("定义的，所以"),t("code",[e._v("props")]),e._v("本身是响应式的，但没有对值进行深度定义，是由于"),t("code",[e._v("props")]),e._v("本身是来自父组件的数据，这个数据可能本身就是响应式的了，就不需要重复定义了。")])])])]),e._v(" "),t("p",[e._v("使用了 "),t("code",[e._v("toggleObserving(false)")])]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("initMethods")])]),e._v(" "),t("ul",[t("li",[e._v("key的处理以及是否和属性定义重名，最后将"),t("code",[e._v("methods")]),e._v("内的方法挂载到"),t("code",[e._v("this")]),e._v("下")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("initData(vm)")])]),e._v(" "),t("ul",[t("li",[e._v("通过"),t("code",[e._v("vm.$options.data")]),e._v("得到用户定义的"),t("code",[e._v("data")]),e._v(",如果是"),t("code",[e._v("function")]),e._v("就执行返回，否则直接返回"),t("code",[e._v("data || {}")]),e._v(",检查不能和"),t("code",[e._v("props、methods 的 key")]),e._v("重名，然后使用proxy做一层代理，直接可以使用实例this可访问，最后通过observe将每一项数据递归遍历成响应式。")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("initProvide(vm)")]),e._v(" 主要作用是初始化"),t("code",[e._v("provide")]),e._v("为子组件提供依赖")]),e._v(" "),t("ul",[t("li",[e._v("provide和inject绑定并不是可相应的，这是刻意为之，只要父组件提供的这个数据本身响应式的，及时defineReactive，那么这个数据最终也是响应式的。")]),e._v(" "),t("li",[e._v("通过"),t("code",[e._v("vm.$options.provide")]),e._v("取得用户定义的"),t("code",[e._v("provide")]),e._v("选项,如果是"),t("code",[e._v("function")]),e._v("类型就执行得到返回结果，将其赋值给"),t("code",[e._v("vm._provided")]),e._v("私有属性，子组件在初始化inject时就可访问到父组件提供依赖")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("callHook(vm, 'created')")]),e._v("，执行用户定义的created钩子函数，有mixin混入也一并执行。")])])]),e._v(" "),t("blockquote",[t("p",[e._v("在methods内可以使用箭头函数吗\n是不可使用，箭头函数在"),t("code",[e._v("this")]),e._v("定义时就绑定吗，在"),t("code",[e._v("vue")]),e._v("内部，"),t("code",[e._v("methods")]),e._v("内的每个方法的上下文就是当前"),t("code",[e._v("vm")]),e._v("组件实例，"),t("code",[e._v("methods[key].bind(vm)")]),e._v(",而如果使用箭头函数，函数的上下文就变成了父级的上下文。")])]),e._v(" "),t("h2",{attrs:{id:"虚拟dom是怎么生成的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom是怎么生成的"}},[e._v("#")]),e._v(" 虚拟Dom是怎么生成的")]),e._v(" "),t("h3",{attrs:{id:"谈谈对虚拟dom的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#谈谈对虚拟dom的理解"}},[e._v("#")]),e._v(" 谈谈对虚拟dom的理解")]),e._v(" "),t("ul",[t("li",[e._v("随着现代应用功能的复杂庞大，管理的状态越多，如果还是使用以前的"),t("code",[e._v("javascript")]),e._v("线程去操作dom，对性能会有很大的损耗，而且状态难以管理，逻辑混乱。")]),e._v(" "),t("li",[e._v("引入虚拟"),t("code",[e._v("dom")]),e._v("，在框架内部就将虚拟dom属性结构与真实dom进行映射，不需命令式操作"),t("code",[e._v("dom")]),e._v("，只需将重心转移到维护树形结构，状态改变就会驱动"),t("code",[e._v("dom")]),e._v("发生改变,具体"),t("code",[e._v("dom")]),e._v("操作框架都帮我们完成，这大部分可在"),t("code",[e._v("javascript")]),e._v("线程完成。")]),e._v(" "),t("li",[e._v("虚拟"),t("code",[e._v("dom")]),e._v("只是一种数据结构，提供了一个抽象层，使得可以跨平台渲染的场景。")])]),e._v(" "),t("h2",{attrs:{id:"揭开数据响应式系统的面纱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#揭开数据响应式系统的面纱"}},[e._v("#")]),e._v(" 揭开数据响应式系统的面纱")]),e._v(" "),t("ul",[t("li",[e._v("从initData开始，initData函数最后会执行observe(data, true)")]),e._v(" "),t("li",[e._v("observe会判断是否拥有__ob__属性，因为是第一次初始化，所以肯定是没有的，因此会执行new Observer")]),e._v(" "),t("li",[e._v("new Observer一个实例时会在内部也new一个dep实例，并且添加__ob__属性，再对数组的元素和对象的属性添加数据劫持(defineReactive)")]),e._v(" "),t("li",[e._v("当挂载时，也就是执行vue.$mount这个函数时，会执行mountComponet")]),e._v(" "),t("li",[e._v("mountComponet会声明updateComponet并将updateComponet作为第二个参数去执行new Watcher")]),e._v(" "),t("li",[e._v("new Wathcer构造函数内部会声明一系列属性，最后会执行watcher.get方法")]),e._v(" "),t("li",[e._v("执行watcher.get方法,会触发pustTarget")]),e._v(" "),t("li",[e._v("pustTarget给Dep.target赋值为当前Wathcer实例然后调用watcher.getter")]),e._v(" "),t("li",[e._v("watcher.getter(updateComponent内部有_update和_render函数)，_render函数会对属性求值，也就触发了属性的get操作")]),e._v(" "),t("li",[e._v("属性的get操作会判断Dep.target是否存在")]),e._v(" "),t("li",[e._v("此时Dep.target是存在的，然后执行dep.depend")]),e._v(" "),t("li",[e._v("dep.depend执行Wathcer.addDep")]),e._v(" "),t("li",[e._v("Wathcer.addDep内部进行了避免重复收集依赖的操作，并且收集依赖")]),e._v(" "),t("li",[e._v("执行完addDep后，此次依赖收集就完成了")]),e._v(" "),t("li",[e._v("数据发生更改，触发setter")]),e._v(" "),t("li",[e._v("set会执行dep.notify")]),e._v(" "),t("li",[e._v("dep.notify会去遍历dep.subs观察者数组，遍历执行watcher.update方法")]),e._v(" "),t("li",[e._v("watcher.update执行了queueWatcher")]),e._v(" "),t("li",[e._v("queueWatcher执行了nextTick(flushSchedulerQueue)")]),e._v(" "),t("li",[e._v("nextTick(flushSchedulerQueue)先把flushSchedulerQueue添加进callbacks回调函数数组")]),e._v(" "),t("li",[e._v("其次nextTick执行timerFunc")]),e._v(" "),t("li",[e._v("timerFunc是异步的(通过Promise,MutationObserver,setImmediate,setTimeout这四种异步方法)执行flushCallbacks")]),e._v(" "),t("li",[e._v("flushCallbacks是异步执行callbacks中所有回调函数，也就是异步执行添加进去的flushSchedulerQueue")]),e._v(" "),t("li",[e._v("flushSchedulerQueue会获取时间戳，对id进行排序，最主要是遍历执行watcher.run方法")]),e._v(" "),t("li",[e._v("atcher.run执行watcher.getter")]),e._v(" "),t("li",[e._v("watcher.getter也就是执行updateComponent")]),e._v(" "),t("li",[e._v("updateComponent将虚拟DOM转换成真实DOM，这里就完成了数据更改后的重新渲染")]),e._v(" "),t("li",[e._v("之后返回flushSchedulerQueue中，继续执行后续函数")]),e._v(" "),t("li",[e._v("先resetSchedulerState重置状态")]),e._v(" "),t("li",[e._v("callActivatedHooks调用组件更新并激活钩子函数")]),e._v(" "),t("li",[e._v("callUpdatedHooks触发updated生命周期钩子函数")]),e._v(" "),t("li",[e._v("至此！一个响应式从头到尾正式完成！")])]),e._v(" "),t("h2",{attrs:{id:"computed实现和缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed实现和缓存机制"}},[e._v("#")]),e._v(" computed实现和缓存机制")]),e._v(" "),t("p",[e._v("1、首先在render函数里面会读取this.info，这个会触发createComputedGetter(key)中的computedGetter(key)；\n2、然后会判断watcher.dirty，执行watcher.evaluate()；\n3、进到watcher.evaluate()，才真想执行this.get方法，这时候会执行pushTarget(this)把当前的computed watcher push到stack里面去，并且把Dep.target 设置成当前的computed watcher`；\n4、然后运行this.getter.call(vm, vm) 相当于运行computed的info: function() { return this.name + this.age }，这个方法；\n5、info函数里面会读取到this.name，这时候就会触发数据响应式Object.defineProperty.get的方法，这里name会进行依赖收集，把watcer收集到对应的dep上面；并且返回name = '张三'的值，age收集同理；\n6、依赖收集完毕之后执行popTarget()，把当前的computed watcher从栈清除，返回计算后的值('张三+10')，并且this.dirty = false；\n7、watcher.evaluate()执行完毕之后，就会判断Dep.target 是不是true，如果有就代表还有渲染watcher，就执行watcher.depend()，然后让watcher里面的deps都收集渲染watcher，这就是双向保存的优势。\n8、此时name都收集了computed watcher 和 渲染watcher。那么设置name的时候都会去更新执行watcher.update()\n9、如果是computed watcher的话不会重新执行一遍只会把this.dirty 设置成 true，如果数据变化的时候再执行watcher.evaluate()进行info更新，没有变化的的话this.dirty 就是false，不会执行info方法。这就是computed缓存机制。")]),e._v(" "),t("h2",{attrs:{id:"编译器生成ast到render函数到vnode再到真实dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译器生成ast到render函数到vnode再到真实dom"}},[e._v("#")]),e._v(" 编译器生成ast到render函数到vnode再到真实dom")]),e._v(" "),t("h2",{attrs:{id:"this-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this-set"}},[e._v("#")]),e._v(" this.$set")]),e._v(" "),t("p",[t("code",[e._v("Vue.$set")]),e._v("先会检测数据类型，如果是基础数据类型，会提示不能设置，如果是数组，会直接添加或替换，如果是对象，这个key存在于对象中，直接替换value，key不存在与对象中，target为非响应式对象，直接给target设置值，target为响应式对象，进行依赖收集。")]),e._v(" "),t("h2",{attrs:{id:"diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[e._v("#")]),e._v(" diff算法")]),e._v(" "),t("p",[e._v("Vue 的 Diff 算法只会同层级比较。因为在大部分情况下，用户跨层级的移动操作特别少，可以忽略不计。\n1、逐层对比【因为同层元素移动比较常见】")]),e._v(" "),t("ul",[t("li",[e._v("如果都是静态节点可以直接跳过。")]),e._v(" "),t("li",[e._v("都是文本节点就直接替换内容（如果内容不相等）。")]),e._v(" "),t("li",[e._v("如果只有新节点，就新增节点。只有只有老节点，就移除。")]),e._v(" "),t("li",[e._v("如果新旧节点都有子节点，就继续比较子节点。循环新的节点，每一个节点都去老的同层节点里遍历，找到了就在进行子元素的比较，继续重复上述流程。如果没有找到，就生成新元素。")])]),e._v(" "),t("p",[e._v("2、算法优化【因为每次全部循环太浪费性能】")]),e._v(" "),t("ul",[t("li",[e._v("静态节点可以直接跳过，例如内容里只有文本。因为不会产生变化。")]),e._v(" "),t("li",[e._v("双端对比（快捷检索）\n在同级移动的情况下（移除、移动、修改某节点），大多数节点的前后节点都是不变的。所以可以假设同坐标的元素是不变的。\n所以可以进行4种双端比较：")]),e._v(" "),t("li",[e._v("新前和旧前（比如只是在列表后新增了元素，那么前面不变的就会在这里返回，直接复用）")]),e._v(" "),t("li",[e._v("新后和旧后（比如只是在列表前新增了元素，上一条没通过，就会一直尾元素比较，直接复用）")]),e._v(" "),t("li",[e._v("新后和旧前")]),e._v(" "),t("li",[e._v("新前和旧后")]),e._v(" "),t("li",[e._v("key优化")]),e._v(" "),t("li",[e._v("将没有通过快捷检索的所有旧元素节点，上的key放到数组oldIndexs中。（移动后指针开始和结尾中为处理的元素）")]),e._v(" "),t("li",[e._v("如果新的元素上面有key值，就去数组中oldIndexs查找。找到了就继续对比2个元素子节点。（记得移动位置）")]),e._v(" "),t("li",[e._v("如果新的元素上面没有key值，就去未出里旧元素中看是否相同的节点，有的话就返回索引index。")]),e._v(" "),t("li",[e._v("通过index，复用元素就继续对比2个元素子节点。（记得移动位置）")])]),e._v(" "),t("p",[e._v("3、删除多余元素\n新的数组和老的数组如果其中1个循环完，就退出循环。\n如果新的Vnode循环完oldStartIdx > oldEndIdx，那就移除oldVnode中未处理的节点。\n如果旧的Vnode循环完newStartIdx > newEndIdx，说明newVode还有剩余。创建新节点，插入Dom中。")]),e._v(" "),t("h3",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),t("p",[e._v("跨平台：Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。\n提高DOM操作效率：把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作（开发者角度，开发者自己可能操作不当，写出低性能的代码），从而提高性能。\n提升渲染性能：在大量、频繁的数据更新下，依托diff算法，能够对视图进行合理、高效的更新。")]),e._v(" "),t("h3",{attrs:{id:"keep-alive-lru-浏览器缓存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-lru-浏览器缓存淘汰策略"}},[e._v("#")]),e._v(" keep-alive lru 浏览器缓存淘汰策略")]),e._v(" "),t("ul",[t("li",[e._v("嵌套route-view，可以对组件页面进行缓存，首次渲染的时候设置缓存，有include和exclude两个属性，使用的是lru 缓存淘汰算法，数据结果是一个链表，如果数据最近被访问过，那么将来被访问的几率会更高，就移到链表的头结点，当链表满的时候，将链表尾部的数据丢弃。")]),e._v(" "),t("li",[e._v("缓存渲染的时候不会执行组件的 created、mounted 等钩子函数, 而是对缓存的组件执行patch 过程，最后直接更新到目标元素")])])])}),[],!1,null,null,null);t.default=s.exports}}]);