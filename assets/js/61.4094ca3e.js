(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{342:function(n,e,t){"use strict";t.r(e);var s=t(14),a=Object(s.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("浏览器")]),n._v(" "),e("p",[n._v("csp\n"),e("mate",{attrs:{"http-equiv":"Content-Security-Policy",content:"default-src https;"}},[n._v("\n禁止向其他域提交数据\n限制其他域的资源加载\ndom层面限制不同源的js脚本对当前dom对象的读取操作\n数据层面限制不同源站点读取当前cookie indexdb, localstorage的读取\n网络层面限制XMLHttpRequest\njs图片不会跨域")])],1),n._v(" "),e("p",[n._v("xss攻击带来的危害，获取cookie信息，修改操作dom，发送恶意请求，在页面生成弹窗广告\n存储型： 常见通过评论等方式，提交恶意代码到服务器，前后端都未将代码过滤，然后用户浏览时，在页面渲染中直接执行，恶意脚本执行过程中会将cookie带到服务器，也可以是生成广告弹窗\n反射型：恶意脚本属于本地的一部分，然后网站又把恶意js脚本返回了用户，然后这段js脚本在用户页面中执行，很常见的是在搜索的时候，通过key-walue方式发送给服务器，直接把value值返回过来，包含了恶意代码\n在现实生活当中，黑客经常会通过qq群或论坛诱导用户点击，web服务器不会存储xss恶意脚本\ndom型：代理劫持，wifi路由器和本地恶意软件\n不相信任何用户输入，对标签转译，特别是常见的<>，充分利用CSP，禁止内联代码执行，以及外域的资源文件，禁止向不同域提交资源，利用cookie的httponly属性在开发中少用v-html、innerhtml等语法\ncsrf，这是用户在A网站登录之后，有了A网站的登录态，被恶意人员引诱到了B网站，B网站是黑客构造好的代码，可以自动利用图片发送get请求，或利用post构建表单发送，向A网站发送请求，这时候是以A的身份发送的请求，会自动带上A等登录信息，这是利用用户对浏览器的信息\n充分里面cookie的samesie属性，常见有严格，（禁止任何） lax，（get请求，a标签跳转）none无限制\ncsrf token，在html生成一个csrftoken，每次请求都带上验证\n验证origin reffer")]),n._v(" "),e("p",[n._v("http对称加密和非对称加密，但是用户涉及到信任的问题，所以就需要CA机构来生成数字证书\n浏览器向服务器发送client-random,加密套件列表\n服务端接收后从浏览器支持的加密套件列表选择加密方法，生成server-random，以及自己的公钥\n浏览器接收结合client-random和server-random生成随机数pre-random用公钥加密，服务端收到后用公钥解密，得到密串\n但是中间交换密钥很容易被中间人截取替换\n所以站点需先向CA机构提交自己的公钥、站点信息认证，CA审核通过会签发认证的数字证书，里面包含了站点信息，公钥、CA的信息、有效时间、证书编号，这些信息都是明文的，同时包含一个CA生成的签名")]),n._v(" "),e("p",[n._v("浏览器收到服务端的数字证书后，会对证书进行验证，首先浏览器读取证书中相关的明文信息，采用CA签名时相同的Hash函数来计算并得到信息摘要A，然后再利用对应CA的公钥解密签名数据，得到信息摘要B，对比两个是否一致")]),n._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[n._v("\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("ul",[e("li",[n._v("requestAnimationFrame\n比如60Hz刷新率，也就是1秒刷新60次，16.6ms刷新一次，这个时候浏览器的渲染间隔时间就没必要小于16.6ms，但是RAF会保证浏览器渲染之前一定会被调用，但是并不再Eventloop生命周期里。在执行 animation  callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue  处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。")]),n._v(" "),e("li",[n._v("requestIdlecallback\n当宏任务队列中没有任务可以处理，浏览器可能会处于空闲状态，这段空闲时间可以被requestIdlecallback利用起来一些优先级不高，不必立即执行的任务。为了防止浏览器一直处于繁忙状态，提供了一个额外的timeout参数，为这个任务设置一个截止时间。浏览器可以根据这截止时间规划这个任务的执行。")])]),n._v(" "),e("h3",{attrs:{id:"js解析和执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js解析和执行"}},[n._v("#")]),n._v(" js解析和执行")]),n._v(" "),e("p",[n._v("解析阶段： 将js代码生成AST，抽象语法树\n生成字节码： 解释器将AST转换成字节码，字节码是AST和机器码之间，需要将其转换成机器码才能执行，为啥要有这一步呢，因为直接转换会带来内存过大的问题，这一步除了不能优化外，还能执行部分字节码\n生成机器码：根据分析数据的情况生成优化好的机器码，性能更好。\n垃圾回收阶段： 将程序中不再使用的内存空间进行回收")])])}),[],!1,null,null,null);e.default=a.exports}}]);