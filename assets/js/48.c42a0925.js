(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{329:function(_,v,o){"use strict";o.r(v);var e=o(14),n=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"pnpm-和-monorepo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-和-monorepo"}},[_._v("#")]),_._v(" pnpm 和 Monorepo")]),_._v(" "),v("h2",{attrs:{id:"npm-yarn-install-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#npm-yarn-install-原理"}},[_._v("#")]),_._v(" npm/yarn install 原理")]),_._v(" "),v("ol",[v("li",[_._v("将依赖包的版本区间解析为某个具体版本号")]),_._v(" "),v("li",[_._v("下载对应版本依赖的tar包到本地离线镜像")]),_._v(" "),v("li",[_._v("将依赖从离线镜像解压到本地")]),_._v(" "),v("li",[_._v("将依赖从缓存拷贝到项目本地的node_modules目录")]),_._v(" "),v("li",[_._v("包目录结构从最初的嵌套改造成了现在的扁平化结构")])]),_._v(" "),v("h2",{attrs:{id:"先理解硬链接和软链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先理解硬链接和软链接"}},[_._v("#")]),_._v(" 先理解硬链接和软链接")]),_._v(" "),v("ol",[v("li",[_._v("硬链接：对文件系统中某个文件的另一种指向，创建硬链接后，原始文件和硬链接文件对外看起来是另外一种指向，但实际上占用同一块存储空间。如果删除了原始文件依然可访问，除非删除所有了硬连接，不能夸文件系统，不能作用于目录，只能用于文件。")]),_._v(" "),v("li",[_._v("软连接：类似"),v("code",[_._v("windows")]),_._v("系统中的快捷方式，软链接文件是一个独立的文件，有自己的存储空间，当原始文件被删除或移动，软连接就会被悬空，指向一个不存在文件路径。可跨文件系统，支持目录。\npnpm 中的硬软链接应用")])]),_._v(" "),v("ul",[v("li",[v("code",[_._v("pnpm")]),_._v("通过使用全局的"),v("code",[_._v(".pnpm-store")]),_._v("来存储下载的包，使用硬连接来重用存储在全局存储中的的包文件，这些不同的项目中相同的包无需重复下载，节约磁盘空间。")]),_._v(" "),v("li",[v("code",[_._v("pnpm")]),_._v("将各类包的不同版本平铺在"),v("code",[_._v("node_modules/.pnpm")]),_._v("下，对于那些需要构建的包，它使用符号链接到存储在项目中的实际位置，这使得包的安装非常迅速，节约磁盘空间。\n"),v("ul",[v("li",[_._v("假如项目中依赖了"),v("code",[_._v("A")]),_._v("，这时候可通过创建软链接，在"),v("code",[_._v("node_modules")]),_._v("跟目录下创建A软连接指向了"),v("code",[_._v("node_modules/.pnpm/A/node_modules/A")]),_._v("，如果"),v("code",[_._v("A")]),_._v("依赖了"),v("code",[_._v("B")]),_._v("，"),v("code",[_._v("pnpm")]),_._v("同样会把B放置在"),v("code",[_._v(".pnpm")]),_._v("中，"),v("code",[_._v("A")]),_._v("同样可以通过软链接依赖到"),v("code",[_._v("B")]),_._v(".")])])])]),_._v(" "),v("h2",{attrs:{id:"限制幽灵依赖产生"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#限制幽灵依赖产生"}},[_._v("#")]),_._v(" 限制幽灵依赖产生")]),_._v(" "),v("ol",[v("li",[_._v("对直接依赖严格管理，只安装在"),v("code",[_._v("package.json")]),_._v("中定义的包")]),_._v(" "),v("li",[_._v("对间接依赖妥协处理： 考虑到某些三方包用到未定义的包，会讲下载的包放在"),v("code",[_._v("node_modules/.pnpm/node_modules")]),_._v("下，这样做的目的是保持依赖隔离的同时，允许某些特殊情况下访问")])]),_._v(" "),v("h3",{attrs:{id:"monorepo能解决什么问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#monorepo能解决什么问题"}},[_._v("#")]),_._v(" Monorepo能解决什么问题")]),_._v(" "),v("p",[_._v("好处")]),_._v(" "),v("ol",[v("li",[_._v("代码复用，多个项目共享一个代码库，避免了再不同项目中重复编写相同功能代码的问题，提高了开发效率")]),_._v(" "),v("li",[_._v("提升协作效率，多个项目在同一个代码仓库中开发，可以方便共享代码和文档，避免不同项目之间的沟通成本")]),_._v(" "),v("li",[_._v("统一构建：可共用一套构建系统和工具链进行构建部署，提升了构建效率")]),_._v(" "),v("li",[_._v("可快速定位问题，所有代码都在一个库中开发，可很方便找到代码文件，便于调试\n弊端：")]),_._v(" "),v("li",[_._v("大仓意味着每个人都有项目的代码权限，严格的CR机制，自动化构建，测试流水线，团队整体代码水平都得有一定的规模和水平")]),_._v(" "),v("li",[_._v("多个项目共用一个组件，如果有一天项目A对该组件有定制需求，并且这个需求事破坏性的，这个时候该怎么协调，还是来单独满足")])])])}),[],!1,null,null,null);v.default=n.exports}}]);