<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue原理常见问题 | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="我的个人网站">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8f3dca9f.css" as="style"><link rel="preload" href="/assets/js/app.e6d790d2.js" as="script"><link rel="preload" href="/assets/js/2.670a8c78.js" as="script"><link rel="preload" href="/assets/js/1.71926bfe.js" as="script"><link rel="preload" href="/assets/js/25.1370aa75.js" as="script"><link rel="prefetch" href="/assets/js/10.66b9053d.js"><link rel="prefetch" href="/assets/js/11.04545941.js"><link rel="prefetch" href="/assets/js/12.1bdea263.js"><link rel="prefetch" href="/assets/js/13.9426da25.js"><link rel="prefetch" href="/assets/js/14.856c1518.js"><link rel="prefetch" href="/assets/js/15.b360c35b.js"><link rel="prefetch" href="/assets/js/16.e925b239.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/20.e4646aa0.js"><link rel="prefetch" href="/assets/js/21.a45f0526.js"><link rel="prefetch" href="/assets/js/22.49faaeca.js"><link rel="prefetch" href="/assets/js/23.c2b62dee.js"><link rel="prefetch" href="/assets/js/24.637d604b.js"><link rel="prefetch" href="/assets/js/26.254ee0fc.js"><link rel="prefetch" href="/assets/js/27.09790146.js"><link rel="prefetch" href="/assets/js/28.7e5b1948.js"><link rel="prefetch" href="/assets/js/29.fce874c1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/30.a2fe8eb2.js"><link rel="prefetch" href="/assets/js/31.162506d4.js"><link rel="prefetch" href="/assets/js/32.3cde0674.js"><link rel="prefetch" href="/assets/js/33.d7d3d255.js"><link rel="prefetch" href="/assets/js/34.70bab86a.js"><link rel="prefetch" href="/assets/js/35.e25e2604.js"><link rel="prefetch" href="/assets/js/36.b5fada05.js"><link rel="prefetch" href="/assets/js/37.e2f9bc23.js"><link rel="prefetch" href="/assets/js/38.24d3a67d.js"><link rel="prefetch" href="/assets/js/39.2b6a21e0.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.d406595a.js"><link rel="prefetch" href="/assets/js/41.917cf6ec.js"><link rel="prefetch" href="/assets/js/42.2a915dbf.js"><link rel="prefetch" href="/assets/js/43.06d233c4.js"><link rel="prefetch" href="/assets/js/44.f41cf9e5.js"><link rel="prefetch" href="/assets/js/45.2f577289.js"><link rel="prefetch" href="/assets/js/46.69e142ff.js"><link rel="prefetch" href="/assets/js/47.6967f1f2.js"><link rel="prefetch" href="/assets/js/48.c42a0925.js"><link rel="prefetch" href="/assets/js/49.396ed3db.js"><link rel="prefetch" href="/assets/js/5.b31b942f.js"><link rel="prefetch" href="/assets/js/50.f9fa87b4.js"><link rel="prefetch" href="/assets/js/51.f5150e72.js"><link rel="prefetch" href="/assets/js/52.5b2e9eb6.js"><link rel="prefetch" href="/assets/js/53.775f3eb1.js"><link rel="prefetch" href="/assets/js/54.af0c3dd1.js"><link rel="prefetch" href="/assets/js/55.062c9831.js"><link rel="prefetch" href="/assets/js/56.3228b669.js"><link rel="prefetch" href="/assets/js/57.3e194052.js"><link rel="prefetch" href="/assets/js/58.0fac8851.js"><link rel="prefetch" href="/assets/js/59.4a2921bc.js"><link rel="prefetch" href="/assets/js/6.4910e764.js"><link rel="prefetch" href="/assets/js/60.aaff0e8d.js"><link rel="prefetch" href="/assets/js/61.4094ca3e.js"><link rel="prefetch" href="/assets/js/62.a4d3e4b0.js"><link rel="prefetch" href="/assets/js/63.90c7781d.js"><link rel="prefetch" href="/assets/js/64.9f28672a.js"><link rel="prefetch" href="/assets/js/65.82d99a34.js"><link rel="prefetch" href="/assets/js/66.4b1a7c79.js"><link rel="prefetch" href="/assets/js/67.cde2a4b8.js"><link rel="prefetch" href="/assets/js/68.7b2ca4b4.js"><link rel="prefetch" href="/assets/js/69.3f6a7106.js"><link rel="prefetch" href="/assets/js/7.c5640ac7.js"><link rel="prefetch" href="/assets/js/70.97a2a772.js"><link rel="prefetch" href="/assets/js/71.35881c3b.js"><link rel="prefetch" href="/assets/js/72.25b350dc.js"><link rel="prefetch" href="/assets/js/73.11c7d3f8.js"><link rel="prefetch" href="/assets/js/74.920a6416.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3dca9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>准备工作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/prepare/" class="sidebar-link">Introduction</a></li><li><a href="/accumulate/prepare/jsbase.html" class="sidebar-link">js基础</a></li><li><a href="/accumulate/prepare/summary.html" class="sidebar-link">写给自己看的js基础灵魂拷问</a></li><li><a href="/accumulate/prepare/init.html" class="sidebar-link">Vue 原理解析</a></li><li><a href="/accumulate/prepare/jsleetcode.html" class="sidebar-link">学习js数据结构与算法 &amp; 算法图解</a></li><li><a href="/accumulate/prepare/vue3.html" class="sidebar-link">vue3的一些改变</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/safety/" class="sidebar-link">Introduction</a></li><li><a href="/accumulate/safety/xsscsrf.html" class="sidebar-link">谈谈XSS与CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/compile/" aria-current="page" class="active sidebar-link">vue2源码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/compile/#vue原理常见问题" class="sidebar-link">vue原理常见问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/compile/#响应式系统" class="sidebar-link">响应式系统</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#初始化前-beforecreate做了写啥" class="sidebar-link">初始化前，beforeCreate做了写啥</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#为什么要依赖收集" class="sidebar-link">为什么要依赖收集</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#什么是vnode" class="sidebar-link">什么是VNode</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#编译compiler阶段做了些啥事" class="sidebar-link">编译Compiler阶段做了些啥事</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#数据更新视图" class="sidebar-link">数据更新视图</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#异步更新" class="sidebar-link">异步更新</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#computed被收集的过程" class="sidebar-link">computed被收集的过程</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#为什么计算属性有缓存功能" class="sidebar-link">为什么计算属性有缓存功能</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#computed属性和watch属性分别什么场景使用" class="sidebar-link">computed属性和watch属性分别什么场景使用</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#自定义事件的机制" class="sidebar-link">自定义事件的机制</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#组件库中命令式弹窗组件的原理" class="sidebar-link">组件库中命令式弹窗组件的原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#vuex常见问题" class="sidebar-link">vuex常见问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/compile/#vuex为什么把异步操作分装在action中" class="sidebar-link">vuex为什么把异步操作分装在action中</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#vuex直接修改state-与-用dispatch-commit来修改state的差异" class="sidebar-link">vuex直接修改state 与 用dispatch／commit来修改state的差异</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#什么时候该用vuex" class="sidebar-link">什么时候该用vuex</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#vuex碰上v-model" class="sidebar-link">vuex碰上v-model</a></li><li class="sidebar-sub-header"><a href="/accumulate/compile/#render-watcher、conputed-watcher、user-watcher区别和原理" class="sidebar-link">render-watcher、conputed-watcher、user-watcher区别和原理</a></li></ul></li></ul></li><li><a href="/accumulate/compile/vdom.html" class="sidebar-link">虚拟dom</a></li><li><a href="/accumulate/compile/parse.html" class="sidebar-link">parse</a></li><li><a href="/accumulate/compile/entrance.html" class="sidebar-link">编译入口</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue原理常见问题"><a href="#vue原理常见问题" class="header-anchor">#</a> vue原理常见问题</h2> <h3 id="响应式系统"><a href="#响应式系统" class="header-anchor">#</a> 响应式系统</h3> <p>通过<code>Object.defineproperty</code>来实现对对象的「响应式」化，入参是一个 <code>obj</code>（需要绑定的对象）、<code>key</code>（<code>obj</code>的某一个属性），<code>val</code>（具体的值）。经过 <code>defineReactive</code> 处理以后，我们的 <code>obj</code> 的 <code>key</code> 属性在「读」的时候会触发 <code>reactiveGetter</code> 方法，而在该属性被「写」的时候则会触发 <code>reactiveSetter</code> 方法。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">defineReactive</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       <span class="token comment">/* 属性可枚举 */</span>
        <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token comment">/* 属性可被修改或删除 */</span>
        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> val<span class="token punctuation">;</span>         <span class="token comment">/* 实际上会依赖收集，下一小节会讲 */</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token function">cb</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="初始化前-beforecreate做了写啥"><a href="#初始化前-beforecreate做了写啥" class="header-anchor">#</a> 初始化前，beforeCreate做了写啥</h3> <ul><li>合并options配置
<ul><li>初始化<code>new Vue</code></li> <li>子组件初始化，确认组件的父子关系和初始化某些实例属性</li> <li>将父组件的自定义事件传递给子组件</li> <li>提供将render函数转为vnode的方法</li> <li>执行组件的beforeCreate钩子函数</li> <li>并且在当前生命周期，是不能访问this中data定义的变量，这个时候data中的变量，还没挂载到this上</li> <li>但是插件内部的install方法是通过Vue.use方法，一般选择在beforeCreate这个钩子内执行</li></ul></li></ul> <h3 id="为什么要依赖收集"><a href="#为什么要依赖收集" class="header-anchor">#</a> 为什么要依赖收集</h3> <ol><li>首先在Observer的过程中会注册get方法，该方法是用来进行依赖收集，在它的闭包中有一个<code>Dep</code>对象，这个对象用来存放<code>Watcher</code>对象的实例，其实依赖收集就是把<code>Watcher</code> 存放对应的<code>Dep</code>对象中去。</li> <li>get方法可以让当前的<code>Watcher</code>对象（Dep.target）存放到它的<code>sub</code>中<code>addSub</code>方法，在数据变化时，<code>set</code>方法会调用<code>Dep</code>对象的<code>notify</code>方法通知它内部所有的<code>Watcher</code>对象进行视图更新。</li></ol> <p>这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个：</p> <ol><li>触发 get 方法；</li> <li>新建一个 Watcher 对象。</li></ol> <p>这个我们在 Vue 的构造类中处理，新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 更新视图的方法 */</span>
    <span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;视图更新啦～&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>而触发 get 方法也很简单，实际上只要把<code>render function</code>进行渲染，那么其中依赖的对象就会被读取，
<img src="/images/image.png" alt="alt text"></p> <h3 id="什么是vnode"><a href="#什么是vnode" class="header-anchor">#</a> 什么是VNode</h3> <p><code>render function</code> 会被转化成 <code>VNode</code> 节点，<code>Virtual DOM</code> 其实就是一棵以 <code>JavaScript</code> 对象（<code>VNode</code> 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 <code>DOM</code> 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p> <h3 id="编译compiler阶段做了些啥事"><a href="#编译compiler阶段做了些啥事" class="header-anchor">#</a> 编译Compiler阶段做了些啥事</h3> <p><code>compiler</code>阶段可以分为 <code>parse</code>、<code>optimize</code>、<code>generate</code>，最终需要得到 <code>render function</code>。</p> <p><code>parse</code>会通过正则等方式将<code>template</code>模版中进行字符串解析，得到指令、<code>class</code>、<code>style</code>，形成<code>AST</code>。</p> <h3 id="数据更新视图"><a href="#数据更新视图" class="header-anchor">#</a> 数据更新视图</h3> <blockquote><p>对<code>model</code>进行操作的时候，会触发对应<code>Dep</code>中的Watcher对象，<code>Watcher</code>对象会调用对应的<code>update</code>来修改视图，最终是将新产生的 <code>VNode</code> 节点与老 <code>VNode</code> 进行一个 <code>patch</code> 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。
其中会进行dom 的diff操作，在patch的时候，主要是通过同层结点对比，而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法</p></blockquote> <p>因为patch的主要功能是对比两个VNode结点，将差异更新到视图上，</p> <h3 id="异步更新"><a href="#异步更新" class="header-anchor">#</a> 异步更新</h3> <h3 id="computed被收集的过程"><a href="#computed被收集的过程" class="header-anchor">#</a> computed被收集的过程</h3> <ul><li>响应式数据被读取到了会触发getter，收集当前的watcher到依赖中，如果模板中用到了，就会读取渲染watcher，在计算属性里用到了就会读取渲染wathcer，只要值发生变化了就会通知计算属性重新计算并进行值返回，最后渲染。</li> <li>computed 属性为什么能够在依赖改变的时候，自己发生变化？</li></ul> <p>(我说 computed 和 watch 公用一个 Watcher 类，在 computed 的情况下有一个 dep 收集依赖，从而达到更新computed属性的效果，顺便跟他讲了computed Watcher如何跟渲染Watcher关联，以及 Vue 在二次收集依赖时用 cleanupDeps 卸载一些无用的 dep)</p> <h3 id="为什么计算属性有缓存功能"><a href="#为什么计算属性有缓存功能" class="header-anchor">#</a> 为什么计算属性有缓存功能</h3> <p>在计算属性经过计算后，内部的标志位dirty已经表明计算过了，再次访问会直接访问读取的值，计算属性如果依赖了响应式属性，内部响应式会收集<code>computed-watcher</code>，当响应式值变化后会通知计算属性重新计算，也会通知页面重新渲染，渲染时会重新读取计算后的值。</p> <h3 id="computed属性和watch属性分别什么场景使用"><a href="#computed属性和watch属性分别什么场景使用" class="header-anchor">#</a> computed属性和watch属性分别什么场景使用</h3> <p>当模板中的某个值需要通过一个或多个数据计算得到时，或者对值进行大量处理，就使用计算属性，还有计算属性不接受参数必须要有值返回，当监听属性主要是监听某个值变化，对新值进行逻辑处理。</p> <h3 id="自定义事件的机制"><a href="#自定义事件的机制" class="header-anchor">#</a> 自定义事件的机制</h3> <p>子组件使用this.$emit触发事件时，会在当前实例的事件中心去查找对应的事件，然后执行，不过这个事件是在父组件的作用域中定义。$emit的参数会传递给父组件的回调函数，完成组件通信。</p> <h3 id="组件库中命令式弹窗组件的原理"><a href="#组件库中命令式弹窗组件的原理" class="header-anchor">#</a> 组件库中命令式弹窗组件的原理</h3> <p>使用extend将组件转为构造函数，在实例化这个构造函数后，就会得到$el属性，也就是组件真实的dom，这个时候可以操作得到真实的dom去挂载，使用命令式也能调用</p> <h2 id="vuex常见问题"><a href="#vuex常见问题" class="header-anchor">#</a> vuex常见问题</h2> <h3 id="vuex为什么把异步操作分装在action中"><a href="#vuex为什么把异步操作分装在action中" class="header-anchor">#</a> vuex为什么把异步操作分装在action中</h3> <p>其实是为了代码隔离，mutation同步是必须的，只做纯函数的变化，不受控的代码集中到action，异步竞态是用户自己的事，处理好了给mutation，去改变state的值。</p> <h3 id="vuex直接修改state-与-用dispatch-commit来修改state的差异"><a href="#vuex直接修改state-与-用dispatch-commit来修改state的差异" class="header-anchor">#</a> vuex直接修改state 与 用dispatch／commit来修改state的差异</h3> <p>使用commit提交到mutation修改state的优点，记录每一次state变化的快照，保存状态快照，做到数据可溯源，单向操作，也便于调试，严格模式下，并且每次都要commit来修改state</p> <h3 id="什么时候该用vuex"><a href="#什么时候该用vuex" class="header-anchor">#</a> 什么时候该用vuex</h3> <ol><li>无法很好进行数据管理的时候，当一个组件需要多次派发数据同步</li> <li>跨组件共享数据，以及跨页面共享数据</li></ol> <h3 id="vuex碰上v-model"><a href="#vuex碰上v-model" class="header-anchor">#</a> vuex碰上v-model</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 可以把v-model拆成</span>
<span class="token operator">&lt;</span>input <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;message&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;updateMessage&quot;</span><span class="token operator">&gt;</span>
<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">message</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token function">updateMessage</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="render-watcher、conputed-watcher、user-watcher区别和原理"><a href="#render-watcher、conputed-watcher、user-watcher区别和原理" class="header-anchor">#</a> render-watcher、conputed-watcher、user-watcher区别和原理</h3> <h4 id="render-watcher"><a href="#render-watcher" class="header-anchor">#</a> render-watcher</h4> <ul><li>render-watcher是vue开发中最重要的实例了，data中属性的更新就会触发视图的更新，在初始化过程中，object.defineproperty会进行依赖收集,收集到的就是render-watcher，添加到这个属性的依赖列表（Dep）实例中。</li> <li>Setter派发更新时，那就是执行render-watcher的回调，Dep实例就会就会通知，然后就会执行这个属性的Watcher实例上的update方法，这个run方法会重新生成执行render-function，如果patch diff更新视图。</li></ul> <h4 id="user-watcher"><a href="#user-watcher" class="header-anchor">#</a> user-watcher</h4> <ul><li>是通过watch或者&amp;watch显示创建的Watcher，这类watch允许开发者自定义响应式数据的变化，开发者可以指定某个响应式数据作为监听目标，并提供一个回调函数，当监听数据变化时，回调函数也会执行。</li> <li>常用于通过监听数据变化执行异步操作，或者根据数据变化进行逻辑判断等任务</li></ul> <h4 id="conputed-watcher"><a href="#conputed-watcher" class="header-anchor">#</a> conputed-watcher</h4> <ul><li>依赖追踪
<ul><li>当定义一个computed属性时，会创建一个Computed Watcher，这个Watcher会在初次访问计算属性时，执行其定义的函数，同时自动追踪函数中所依赖的所有响应式属性。</li> <li>依赖收集： 在computed对象初始化期间，任何被访问的响应式数据都会将computed watcher收集他们各自的依赖列表（Dep实例），一旦依赖数据发生变更，Computed Watcher就会被通知;</li></ul></li> <li>缓存
<ul><li>computed具有缓存机制，当计算属性经过计算后，内部的标志位会表明已经计算过了，Computed-watcher会缓存计算结果，只有依赖的数据发生变化会重新计算，因为内部的响应式数据会收集computed-watcher，变更后通知计算属性基性计算，也会通知页面重新渲染，渲染时会重新读取重新计算后的值</li></ul></li></ul> <h4 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>初始化: 当组件被创建时，vue在进行响应式收集的时候，会分别为a和b创建一个Dep实例，同时对于计算属性sum，vue会创建一个特殊的Watcvher（computed watcher）</li> <li>依赖收集：
<ul><li>当 sum 第一次被访问时，它的 Computed Watcher 被激活。</li> <li>Computed Watcher 开始执行 sum 的定义函数（return this.a + this.b;）。</li> <li>当访问 a 和 b 时，它们各自的 getter 函数被调用。在 getter 中，Vue 检测到当前有一个活跃的 Watcher（sum 的 Computed Watcher）。</li> <li>a 和 b 的 Dep 将这个 Watcher 添加到它们的依赖列表中。</li> <li>同时，Watcher 记录它依赖于 a 和 b 的 Dep。（这个是避免重复收集，管理和优化依赖关系，当某个数据项不再使用，watcher可据此清除掉这个数据的依赖关系，减少不必要的计算和监听，精确的更新机制，只有真正依赖的这些数据的Watcher会被通知更新）</li></ul></li> <li>响应更新：
<ul><li>假设 a 的值从 1 变为 3。a 的 setter 被调用，它通知 a 的 Dep。</li> <li>a 的 Dep 遍历它的依赖列表（包含 sum 的 Watcher），并通知这些 Watcher 数据已变化。</li> <li>sum 的 Watcher 收到通知后，标记自己为 &quot;dirty&quot;，表示计算属性的结果可能已经变化，需要重新计算。</li> <li>下次 sum 被访问时，它的 Watcher 会重新计算 sum 的值。</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">4/19/2024, 5:54:44 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/accumulate/safety/xsscsrf.html" class="prev">
        谈谈XSS与CSRF
      </a></span> <span class="next"><a href="/accumulate/compile/vdom.html">
        虚拟dom
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6d790d2.js" defer></script><script src="/assets/js/2.670a8c78.js" defer></script><script src="/assets/js/1.71926bfe.js" defer></script><script src="/assets/js/25.1370aa75.js" defer></script>
  </body>
</html>
