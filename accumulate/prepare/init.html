<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 原理解析 | 个人主页</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/photo.jpg">
    <link rel="manifest" href="/images/photo.jpg">
    <link rel="apple-touch-icon" href="/images/photo.jpg">
    <meta name="description" content="我的个人网站">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8f3dca9f.css" as="style"><link rel="preload" href="/assets/js/app.e6d790d2.js" as="script"><link rel="preload" href="/assets/js/2.670a8c78.js" as="script"><link rel="preload" href="/assets/js/1.71926bfe.js" as="script"><link rel="preload" href="/assets/js/30.a2fe8eb2.js" as="script"><link rel="prefetch" href="/assets/js/10.66b9053d.js"><link rel="prefetch" href="/assets/js/11.04545941.js"><link rel="prefetch" href="/assets/js/12.1bdea263.js"><link rel="prefetch" href="/assets/js/13.9426da25.js"><link rel="prefetch" href="/assets/js/14.856c1518.js"><link rel="prefetch" href="/assets/js/15.b360c35b.js"><link rel="prefetch" href="/assets/js/16.e925b239.js"><link rel="prefetch" href="/assets/js/17.5b873df7.js"><link rel="prefetch" href="/assets/js/18.4c170722.js"><link rel="prefetch" href="/assets/js/19.a45744ea.js"><link rel="prefetch" href="/assets/js/20.e4646aa0.js"><link rel="prefetch" href="/assets/js/21.a45f0526.js"><link rel="prefetch" href="/assets/js/22.49faaeca.js"><link rel="prefetch" href="/assets/js/23.c2b62dee.js"><link rel="prefetch" href="/assets/js/24.637d604b.js"><link rel="prefetch" href="/assets/js/25.1370aa75.js"><link rel="prefetch" href="/assets/js/26.254ee0fc.js"><link rel="prefetch" href="/assets/js/27.09790146.js"><link rel="prefetch" href="/assets/js/28.7e5b1948.js"><link rel="prefetch" href="/assets/js/29.fce874c1.js"><link rel="prefetch" href="/assets/js/3.4db2e19a.js"><link rel="prefetch" href="/assets/js/31.162506d4.js"><link rel="prefetch" href="/assets/js/32.3cde0674.js"><link rel="prefetch" href="/assets/js/33.d7d3d255.js"><link rel="prefetch" href="/assets/js/34.70bab86a.js"><link rel="prefetch" href="/assets/js/35.e25e2604.js"><link rel="prefetch" href="/assets/js/36.b5fada05.js"><link rel="prefetch" href="/assets/js/37.e2f9bc23.js"><link rel="prefetch" href="/assets/js/38.24d3a67d.js"><link rel="prefetch" href="/assets/js/39.2b6a21e0.js"><link rel="prefetch" href="/assets/js/4.45665f8a.js"><link rel="prefetch" href="/assets/js/40.d406595a.js"><link rel="prefetch" href="/assets/js/41.917cf6ec.js"><link rel="prefetch" href="/assets/js/42.2a915dbf.js"><link rel="prefetch" href="/assets/js/43.06d233c4.js"><link rel="prefetch" href="/assets/js/44.f41cf9e5.js"><link rel="prefetch" href="/assets/js/45.2f577289.js"><link rel="prefetch" href="/assets/js/46.69e142ff.js"><link rel="prefetch" href="/assets/js/47.6967f1f2.js"><link rel="prefetch" href="/assets/js/48.c42a0925.js"><link rel="prefetch" href="/assets/js/49.396ed3db.js"><link rel="prefetch" href="/assets/js/5.b31b942f.js"><link rel="prefetch" href="/assets/js/50.f9fa87b4.js"><link rel="prefetch" href="/assets/js/51.f5150e72.js"><link rel="prefetch" href="/assets/js/52.5b2e9eb6.js"><link rel="prefetch" href="/assets/js/53.775f3eb1.js"><link rel="prefetch" href="/assets/js/54.af0c3dd1.js"><link rel="prefetch" href="/assets/js/55.062c9831.js"><link rel="prefetch" href="/assets/js/56.3228b669.js"><link rel="prefetch" href="/assets/js/57.3e194052.js"><link rel="prefetch" href="/assets/js/58.0fac8851.js"><link rel="prefetch" href="/assets/js/59.4a2921bc.js"><link rel="prefetch" href="/assets/js/6.4910e764.js"><link rel="prefetch" href="/assets/js/60.aaff0e8d.js"><link rel="prefetch" href="/assets/js/61.4094ca3e.js"><link rel="prefetch" href="/assets/js/62.a4d3e4b0.js"><link rel="prefetch" href="/assets/js/63.90c7781d.js"><link rel="prefetch" href="/assets/js/64.9f28672a.js"><link rel="prefetch" href="/assets/js/65.82d99a34.js"><link rel="prefetch" href="/assets/js/66.4b1a7c79.js"><link rel="prefetch" href="/assets/js/67.cde2a4b8.js"><link rel="prefetch" href="/assets/js/68.7b2ca4b4.js"><link rel="prefetch" href="/assets/js/69.3f6a7106.js"><link rel="prefetch" href="/assets/js/7.c5640ac7.js"><link rel="prefetch" href="/assets/js/70.97a2a772.js"><link rel="prefetch" href="/assets/js/71.35881c3b.js"><link rel="prefetch" href="/assets/js/72.25b350dc.js"><link rel="prefetch" href="/assets/js/73.11c7d3f8.js"><link rel="prefetch" href="/assets/js/74.920a6416.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3dca9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link router-link-active">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/prepare/" class="nav-link router-link-active">
  前端基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="/network/guide/" class="nav-link">
  网络
</a></div><div class="nav-item"><a href="/miniprogram/" class="nav-link">
  小程序
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/front-end-playground/" class="nav-link">
  前端的进击
</a></div><div class="nav-item"><a href="/others/" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>准备工作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/prepare/" aria-current="page" class="sidebar-link">Introduction</a></li><li><a href="/accumulate/prepare/jsbase.html" class="sidebar-link">js基础</a></li><li><a href="/accumulate/prepare/summary.html" class="sidebar-link">写给自己看的js基础灵魂拷问</a></li><li><a href="/accumulate/prepare/init.html" aria-current="page" class="active sidebar-link">Vue 原理解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#初始化时beforecreate之前做了什么" class="sidebar-link">初始化时beforeCreate之前做了什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#合并options配置" class="sidebar-link">合并options配置</a></li></ul></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#初始化时created之前做了什么" class="sidebar-link">初始化时created之前做了什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#initstate" class="sidebar-link">initState</a></li></ul></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#虚拟dom是怎么生成的" class="sidebar-link">虚拟Dom是怎么生成的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#谈谈对虚拟dom的理解" class="sidebar-link">谈谈对虚拟dom的理解</a></li></ul></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#揭开数据响应式系统的面纱" class="sidebar-link">揭开数据响应式系统的面纱</a></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#computed实现和缓存机制" class="sidebar-link">computed实现和缓存机制</a></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#编译器生成ast到render函数到vnode再到真实dom" class="sidebar-link">编译器生成ast到render函数到vnode再到真实dom</a></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#this-set" class="sidebar-link">this.$set</a></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#diff算法" class="sidebar-link">diff算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/accumulate/prepare/init.html#keep-alive-lru-浏览器缓存淘汰策略" class="sidebar-link">keep-alive lru 浏览器缓存淘汰策略</a></li></ul></li></ul></li><li><a href="/accumulate/prepare/jsleetcode.html" class="sidebar-link">学习js数据结构与算法 &amp; 算法图解</a></li><li><a href="/accumulate/prepare/vue3.html" class="sidebar-link">vue3的一些改变</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/safety/" class="sidebar-link">Introduction</a></li><li><a href="/accumulate/safety/xsscsrf.html" class="sidebar-link">谈谈XSS与CSRF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/accumulate/compile/" class="sidebar-link">vue2源码</a></li><li><a href="/accumulate/compile/vdom.html" class="sidebar-link">虚拟dom</a></li><li><a href="/accumulate/compile/parse.html" class="sidebar-link">parse</a></li><li><a href="/accumulate/compile/entrance.html" class="sidebar-link">编译入口</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-原理解析"><a href="#vue-原理解析" class="header-anchor">#</a> Vue 原理解析</h1> <ul><li>参考</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>https://blog.csdn.net/qq_46299172/article/details/107609251
https://juejin.cn/post/6844903894980509703
http://caibaojian.com/vue-design/art/9vue-state-init.html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="初始化时beforecreate之前做了什么"><a href="#初始化时beforecreate之前做了什么" class="header-anchor">#</a> 初始化时beforeCreate之前做了什么</h2> <p>在执行<code>new Vue()</code>时，内部会执行一个<code>this._init()</code>，是在<code>initMixin(Vue)</code>内定义的</p> <h3 id="合并options配置"><a href="#合并options配置" class="header-anchor">#</a> 合并options配置</h3> <p>合并完options并在实例上挂载一个<code>$options</code>属性</p> <ol><li><p>初始化new Vue()
在执行<code>new Vue</code>构造函数时，参数是一个对象，也就是用户自定义配置，会将它和<code>vue</code>之前定义的原型方法，全局<code>API</code>属性，还有全局的<code>Vue.mixin</code>内的参数进行合并,合并成一个新的<code>options</code>，最后赋值给一个新属性<code>$options</code></p></li> <li><p>子组件初始化
如果是子组件初始化，除了合并以上那些外，还会将父组件的参数进行合并，比如父组件在子组件上顶一个<code>event、props</code>等</p></li></ol> <p>经过合并之后就可以通过<code>this.$options.data</code>访问到用户定义的data函数,<code>this.$options.name</code>访问到用户定义的组件名称</p> <p>会按照顺序初始化方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><p><code>initLifecycle(vm)</code> 主要是确定组件的父子关系和初始化某些实例属性</p> <ul><li>判断parent结单是否存在，并且判断是否存在抽象节点，如父实例parent是抽象组件，则继续找parent上的parent，直到找到非抽象组件为止。然后将当前实例push到找到父级的<code>$children</code>实例属性内，建立父子关系</li></ul></li> <li><p><code>initEvents(vm)</code>主要作用是将父组件在使用v-on或@注册的自定义事件添加到子组件的事件中心</p> <ul><li>原生事件
<ul><li>在执行<code>initEvents</code>之前的模板编译阶段，会判断遇到的是<code>html标签</code>还是组件名，如果是<code>html标签</code>会转为<code>真实dom</code>之后使用<code>addEventListener</code>注册浏览器原生事件。绑定事件是<code>挂载dom</code>的最后阶段，这只是初始阶段</li></ul></li> <li>自定义事件
<ul><li>经历<code>options</code>阶段后，子组件就可从<code>vm.$options._parentListeners</code>读取到父组件的自定义事件</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token operator">&lt;</span>child<span class="token operator">-</span>components @select<span class="token operator">=</span><span class="token string">&quot;handleSelect&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>传过来的时间数据格式是<code>{select: function(){}}</code>在<code>initEvents</code>方法内定义<code>vm._events</code>用来存储传过来的时间集合</p></li> <li><p><code>initRender(vm)</code>主要作用是挂载可以将<code>render函数</code>转为<code>vnode方法</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initRender</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token operator">...</span>
  vm<span class="token punctuation">.</span><span class="token function-variable function">_c</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token comment">//转化编译器的</span>
  vm<span class="token punctuation">.</span><span class="token function-variable function">$createElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">// 转化手写的</span>
  <span class="token operator">...</span>`
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>vm._c转换的是通过编译器将tempate转换而来的render函数</li> <li>vm.$createElement转换的是用户自定义的render函数，将内部自定义的树形结构数据转为vnode实例</li></ul></li> <li><p><code>callHook(vm, 'beforeCreate')</code></p> <ul><li>实例的第一个生命周期钩子阶段的初始化, 确认组件<code>(Vue实例)</code>父子关系，将父组件的自定义事件传递给子组件，提供将render函数转化为vnode方法，执行组件beforeCreate钩子函数</li> <li>插件内部的<code>install</code>方法是通过<code>Vue.use</code>方法安装一般选择在<code>beforeCreated</code>，是由于这个时候可以访问到vue实例，可以进行必要的初始化</li></ul></li> <li><p><code>initInjections(vm)</code> 主要作用是初始化inject，可以访问到对应的依赖
<code>provide和inject</code>主要是为高阶组件/组件库提供实例</p></li></ul> <h2 id="初始化时created之前做了什么"><a href="#初始化时created之前做了什么" class="header-anchor">#</a> 初始化时created之前做了什么</h2> <h3 id="initstate"><a href="#initstate" class="header-anchor">#</a> initState</h3> <ul><li><code>initProps</code> <ul><li>在定义<code>props</code>数据时，不将prop值转为响应式数据，值得注意的是，由于<code>props</code>本身通过<code>defineReactive</code>定义的，所以<code>props</code>本身是响应式的，但没有对值进行深度定义，是由于<code>props</code>本身是来自父组件的数据，这个数据可能本身就是响应式的了，就不需要重复定义了。</li></ul></li></ul> <p>使用了 <code>toggleObserving(false)</code></p> <ul><li><p><code>initMethods</code></p> <ul><li>key的处理以及是否和属性定义重名，最后将<code>methods</code>内的方法挂载到<code>this</code>下</li></ul></li> <li><p><code>initData(vm)</code></p> <ul><li>通过<code>vm.$options.data</code>得到用户定义的<code>data</code>,如果是<code>function</code>就执行返回，否则直接返回<code>data || {}</code>,检查不能和<code>props、methods 的 key</code>重名，然后使用proxy做一层代理，直接可以使用实例this可访问，最后通过observe将每一项数据递归遍历成响应式。</li></ul></li> <li><p><code>initProvide(vm)</code> 主要作用是初始化<code>provide</code>为子组件提供依赖</p> <ul><li>provide和inject绑定并不是可相应的，这是刻意为之，只要父组件提供的这个数据本身响应式的，及时defineReactive，那么这个数据最终也是响应式的。</li> <li>通过<code>vm.$options.provide</code>取得用户定义的<code>provide</code>选项,如果是<code>function</code>类型就执行得到返回结果，将其赋值给<code>vm._provided</code>私有属性，子组件在初始化inject时就可访问到父组件提供依赖</li></ul></li> <li><p><code>callHook(vm, 'created')</code>，执行用户定义的created钩子函数，有mixin混入也一并执行。</p></li></ul> <blockquote><p>在methods内可以使用箭头函数吗
是不可使用，箭头函数在<code>this</code>定义时就绑定吗，在<code>vue</code>内部，<code>methods</code>内的每个方法的上下文就是当前<code>vm</code>组件实例，<code>methods[key].bind(vm)</code>,而如果使用箭头函数，函数的上下文就变成了父级的上下文。</p></blockquote> <h2 id="虚拟dom是怎么生成的"><a href="#虚拟dom是怎么生成的" class="header-anchor">#</a> 虚拟Dom是怎么生成的</h2> <h3 id="谈谈对虚拟dom的理解"><a href="#谈谈对虚拟dom的理解" class="header-anchor">#</a> 谈谈对虚拟dom的理解</h3> <ul><li>随着现代应用功能的复杂庞大，管理的状态越多，如果还是使用以前的<code>javascript</code>线程去操作dom，对性能会有很大的损耗，而且状态难以管理，逻辑混乱。</li> <li>引入虚拟<code>dom</code>，在框架内部就将虚拟dom属性结构与真实dom进行映射，不需命令式操作<code>dom</code>，只需将重心转移到维护树形结构，状态改变就会驱动<code>dom</code>发生改变,具体<code>dom</code>操作框架都帮我们完成，这大部分可在<code>javascript</code>线程完成。</li> <li>虚拟<code>dom</code>只是一种数据结构，提供了一个抽象层，使得可以跨平台渲染的场景。</li></ul> <h2 id="揭开数据响应式系统的面纱"><a href="#揭开数据响应式系统的面纱" class="header-anchor">#</a> 揭开数据响应式系统的面纱</h2> <ul><li>从initData开始，initData函数最后会执行observe(data, true)</li> <li>observe会判断是否拥有__ob__属性，因为是第一次初始化，所以肯定是没有的，因此会执行new Observer</li> <li>new Observer一个实例时会在内部也new一个dep实例，并且添加__ob__属性，再对数组的元素和对象的属性添加数据劫持(defineReactive)</li> <li>当挂载时，也就是执行vue.$mount这个函数时，会执行mountComponet</li> <li>mountComponet会声明updateComponet并将updateComponet作为第二个参数去执行new Watcher</li> <li>new Wathcer构造函数内部会声明一系列属性，最后会执行watcher.get方法</li> <li>执行watcher.get方法,会触发pustTarget</li> <li>pustTarget给Dep.target赋值为当前Wathcer实例然后调用watcher.getter</li> <li>watcher.getter(updateComponent内部有_update和_render函数)，_render函数会对属性求值，也就触发了属性的get操作</li> <li>属性的get操作会判断Dep.target是否存在</li> <li>此时Dep.target是存在的，然后执行dep.depend</li> <li>dep.depend执行Wathcer.addDep</li> <li>Wathcer.addDep内部进行了避免重复收集依赖的操作，并且收集依赖</li> <li>执行完addDep后，此次依赖收集就完成了</li> <li>数据发生更改，触发setter</li> <li>set会执行dep.notify</li> <li>dep.notify会去遍历dep.subs观察者数组，遍历执行watcher.update方法</li> <li>watcher.update执行了queueWatcher</li> <li>queueWatcher执行了nextTick(flushSchedulerQueue)</li> <li>nextTick(flushSchedulerQueue)先把flushSchedulerQueue添加进callbacks回调函数数组</li> <li>其次nextTick执行timerFunc</li> <li>timerFunc是异步的(通过Promise,MutationObserver,setImmediate,setTimeout这四种异步方法)执行flushCallbacks</li> <li>flushCallbacks是异步执行callbacks中所有回调函数，也就是异步执行添加进去的flushSchedulerQueue</li> <li>flushSchedulerQueue会获取时间戳，对id进行排序，最主要是遍历执行watcher.run方法</li> <li>atcher.run执行watcher.getter</li> <li>watcher.getter也就是执行updateComponent</li> <li>updateComponent将虚拟DOM转换成真实DOM，这里就完成了数据更改后的重新渲染</li> <li>之后返回flushSchedulerQueue中，继续执行后续函数</li> <li>先resetSchedulerState重置状态</li> <li>callActivatedHooks调用组件更新并激活钩子函数</li> <li>callUpdatedHooks触发updated生命周期钩子函数</li> <li>至此！一个响应式从头到尾正式完成！</li></ul> <h2 id="computed实现和缓存机制"><a href="#computed实现和缓存机制" class="header-anchor">#</a> computed实现和缓存机制</h2> <p>1、首先在render函数里面会读取this.info，这个会触发createComputedGetter(key)中的computedGetter(key)；
2、然后会判断watcher.dirty，执行watcher.evaluate()；
3、进到watcher.evaluate()，才真想执行this.get方法，这时候会执行pushTarget(this)把当前的computed watcher push到stack里面去，并且把Dep.target 设置成当前的computed watcher`；
4、然后运行this.getter.call(vm, vm) 相当于运行computed的info: function() { return this.name + this.age }，这个方法；
5、info函数里面会读取到this.name，这时候就会触发数据响应式Object.defineProperty.get的方法，这里name会进行依赖收集，把watcer收集到对应的dep上面；并且返回name = '张三'的值，age收集同理；
6、依赖收集完毕之后执行popTarget()，把当前的computed watcher从栈清除，返回计算后的值('张三+10')，并且this.dirty = false；
7、watcher.evaluate()执行完毕之后，就会判断Dep.target 是不是true，如果有就代表还有渲染watcher，就执行watcher.depend()，然后让watcher里面的deps都收集渲染watcher，这就是双向保存的优势。
8、此时name都收集了computed watcher 和 渲染watcher。那么设置name的时候都会去更新执行watcher.update()
9、如果是computed watcher的话不会重新执行一遍只会把this.dirty 设置成 true，如果数据变化的时候再执行watcher.evaluate()进行info更新，没有变化的的话this.dirty 就是false，不会执行info方法。这就是computed缓存机制。</p> <h2 id="编译器生成ast到render函数到vnode再到真实dom"><a href="#编译器生成ast到render函数到vnode再到真实dom" class="header-anchor">#</a> 编译器生成ast到render函数到vnode再到真实dom</h2> <h2 id="this-set"><a href="#this-set" class="header-anchor">#</a> this.$set</h2> <p><code>Vue.$set</code>先会检测数据类型，如果是基础数据类型，会提示不能设置，如果是数组，会直接添加或替换，如果是对象，这个key存在于对象中，直接替换value，key不存在与对象中，target为非响应式对象，直接给target设置值，target为响应式对象，进行依赖收集。</p> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <p>Vue 的 Diff 算法只会同层级比较。因为在大部分情况下，用户跨层级的移动操作特别少，可以忽略不计。
1、逐层对比【因为同层元素移动比较常见】</p> <ul><li>如果都是静态节点可以直接跳过。</li> <li>都是文本节点就直接替换内容（如果内容不相等）。</li> <li>如果只有新节点，就新增节点。只有只有老节点，就移除。</li> <li>如果新旧节点都有子节点，就继续比较子节点。循环新的节点，每一个节点都去老的同层节点里遍历，找到了就在进行子元素的比较，继续重复上述流程。如果没有找到，就生成新元素。</li></ul> <p>2、算法优化【因为每次全部循环太浪费性能】</p> <ul><li>静态节点可以直接跳过，例如内容里只有文本。因为不会产生变化。</li> <li>双端对比（快捷检索）
在同级移动的情况下（移除、移动、修改某节点），大多数节点的前后节点都是不变的。所以可以假设同坐标的元素是不变的。
所以可以进行4种双端比较：</li> <li>新前和旧前（比如只是在列表后新增了元素，那么前面不变的就会在这里返回，直接复用）</li> <li>新后和旧后（比如只是在列表前新增了元素，上一条没通过，就会一直尾元素比较，直接复用）</li> <li>新后和旧前</li> <li>新前和旧后</li> <li>key优化</li> <li>将没有通过快捷检索的所有旧元素节点，上的key放到数组oldIndexs中。（移动后指针开始和结尾中为处理的元素）</li> <li>如果新的元素上面有key值，就去数组中oldIndexs查找。找到了就继续对比2个元素子节点。（记得移动位置）</li> <li>如果新的元素上面没有key值，就去未出里旧元素中看是否相同的节点，有的话就返回索引index。</li> <li>通过index，复用元素就继续对比2个元素子节点。（记得移动位置）</li></ul> <p>3、删除多余元素
新的数组和老的数组如果其中1个循环完，就退出循环。
如果新的Vnode循环完oldStartIdx &gt; oldEndIdx，那就移除oldVnode中未处理的节点。
如果旧的Vnode循环完newStartIdx &gt; newEndIdx，说明newVode还有剩余。创建新节点，插入Dom中。</p> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <p>跨平台：Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。
提高DOM操作效率：把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作（开发者角度，开发者自己可能操作不当，写出低性能的代码），从而提高性能。
提升渲染性能：在大量、频繁的数据更新下，依托diff算法，能够对视图进行合理、高效的更新。</p> <h3 id="keep-alive-lru-浏览器缓存淘汰策略"><a href="#keep-alive-lru-浏览器缓存淘汰策略" class="header-anchor">#</a> keep-alive lru 浏览器缓存淘汰策略</h3> <ul><li>嵌套route-view，可以对组件页面进行缓存，首次渲染的时候设置缓存，有include和exclude两个属性，使用的是lru 缓存淘汰算法，数据结果是一个链表，如果数据最近被访问过，那么将来被访问的几率会更高，就移到链表的头结点，当链表满的时候，将链表尾部的数据丢弃。</li> <li>缓存渲染的时候不会执行组件的 created、mounted 等钩子函数, 而是对缓存的组件执行patch 过程，最后直接更新到目标元素</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">4/19/2024, 5:54:44 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/accumulate/prepare/summary.html" class="prev">
        写给自己看的js基础灵魂拷问
      </a></span> <span class="next"><a href="/accumulate/prepare/jsleetcode.html">
        学习js数据结构与算法 &amp; 算法图解
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6d790d2.js" defer></script><script src="/assets/js/2.670a8c78.js" defer></script><script src="/assets/js/1.71926bfe.js" defer></script><script src="/assets/js/30.a2fe8eb2.js" defer></script>
  </body>
</html>
